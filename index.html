<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wireframe City Shooter</title>
<style>
  :root {
    color-scheme: dark;
  }
  html, body {
    height: 100%;
    margin: 0;
    background: radial-gradient(circle at 50% 35%, #001636 0%, #02060d 60%, #01030a 100%);
    font-family: "Helvetica Neue", system-ui, sans-serif;
    color: #cbe7ff;
  }
  #hud {
    position: fixed;
    top: 16px;
    left: 16px;
    font-size: 13px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    opacity: 0.85;
    pointer-events: none;
  }
  canvas {
    display: block;
    width: 100vw;
    height: 100vh;
  }
</style>
</head>
<body>
<canvas id="view" width="1280" height="720"></canvas>
<div id="hud">CITY RUN / WIREFRAME MODE</div>
<script>
(() => {
  "use strict";
  const canvas = document.getElementById("view");
  const ctx = canvas.getContext("2d", { alpha: false });
  const hudLabel = document.getElementById("hud");

  // === 表示設定 ===
  const display = {
    fov: 1.2,          // 遠近感の強さ
    zNear: 1.0,        // ニアクリップ
    zFar: 4000.0,      // ファークリップ
    filmHeight: 1.0,   // 正規化されたフィルムサイズ
  };

  // === 入力状態 ===
  const keys = new Set();

  // === オーディオシステム構築（ユーザー操作後に初期化） ===
  const audioSystem = (() => {
    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
    let ctx = null;
    let noiseBuffer = null;

    // 乱数ノイズのバッファを生成して爆発音の素材とする
    const getNoiseBuffer = (context) => {
      if (noiseBuffer) return noiseBuffer;
      const duration = 1.2;
      const buffer = context.createBuffer(1, Math.floor(context.sampleRate * duration), context.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      noiseBuffer = buffer;
      return noiseBuffer;
    };

    // コンテキストを確保し、必要に応じて再開する
    const withContext = (fn) => {
      if (!AudioContextClass) return;
      if (!ctx) {
        ctx = new AudioContextClass();
      }
      if (ctx.state === "suspended") {
        ctx.resume();
      }
      fn(ctx);
    };

    return {
      resume() {
        if (!AudioContextClass) return;
        if (!ctx) {
          ctx = new AudioContextClass();
        }
        if (ctx.state === "suspended") {
          ctx.resume();
        }
      },
      playLaserShot() {
        withContext((context) => {
          const now = context.currentTime;
          const gain = context.createGain();
          gain.gain.setValueAtTime(0.22, now);
          gain.gain.exponentialRampToValueAtTime(0.002, now + 0.16);

          const osc = context.createOscillator();
          osc.type = "sawtooth";
          osc.frequency.setValueAtTime(880, now);
          osc.frequency.exponentialRampToValueAtTime(1660, now + 0.12);

          osc.connect(gain).connect(context.destination);
          osc.start(now);
          osc.stop(now + 0.18);
        });
      },
      playExplosion(intensity = 1) {
        withContext((context) => {
          const now = context.currentTime;
          const source = context.createBufferSource();
          source.buffer = getNoiseBuffer(context);

          const filter = context.createBiquadFilter();
          filter.type = "lowpass";
          const cutoff = 600 + Math.min(intensity, 4) * 420;
          filter.frequency.setValueAtTime(cutoff, now);
          filter.Q.setValueAtTime(0.8, now);

          const gain = context.createGain();
          const startGain = 0.32 * Math.min(intensity, 3.5);
          gain.gain.setValueAtTime(startGain, now);
          gain.gain.exponentialRampToValueAtTime(0.002, now + 0.9);

          source.connect(filter).connect(gain).connect(context.destination);
          source.start(now);
          source.stop(now + 1.0);
        });
      },
      playWaveCannon() {
        withContext((context) => {
          const now = context.currentTime;
          const duration = 1.8;

          const bassOsc = context.createOscillator();
          bassOsc.type = "square";
          bassOsc.frequency.setValueAtTime(110, now);
          bassOsc.frequency.exponentialRampToValueAtTime(260, now + 0.9);

          const bassGain = context.createGain();
          bassGain.gain.setValueAtTime(0.3, now);
          bassGain.gain.linearRampToValueAtTime(0.0, now + duration);

          const airSource = context.createBufferSource();
          airSource.buffer = getNoiseBuffer(context);

          const bandPass = context.createBiquadFilter();
          bandPass.type = "bandpass";
          bandPass.frequency.setValueAtTime(900, now);
          bandPass.Q.setValueAtTime(1.6, now);

          const airGain = context.createGain();
          airGain.gain.setValueAtTime(0.26, now);
          airGain.gain.linearRampToValueAtTime(0.0, now + duration);

          bassOsc.connect(bassGain).connect(context.destination);
          airSource.connect(bandPass).connect(airGain).connect(context.destination);

          bassOsc.start(now);
          bassOsc.stop(now + duration);
          airSource.start(now);
          airSource.stop(now + duration);
        });
      },
    };
  })();
  window.addEventListener("keydown", (ev) => {
    if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Space", "KeyW", "KeyA", "KeyS", "KeyD"].includes(ev.code)) {
      ev.preventDefault();
    }
    audioSystem.resume(); // キー操作でオーディオコンテキストを解放
    keys.add(ev.code);
    if (!ev.repeat && ev.code === "KeyF") {
      missileRequest = true; // ミサイルは単発入力で発射要求
    }
  }, { passive: false });
  window.addEventListener("keyup", (ev) => keys.delete(ev.code));
  window.addEventListener("pointerdown", () => audioSystem.resume(), { passive: true });
  window.addEventListener("touchstart", () => audioSystem.resume(), { passive: true });

  // === ベクトル演算ユーティリティ ===
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  // === イージング関数 ===
  const easeInOutCubic = (t) => (t <= 0 ? 0 : t >= 1 ? 1 : t < 0.5
    ? 4 * t * t * t
    : 1 - Math.pow(-2 * t + 2, 3) * 0.5);
  const easeOutCubic = (t) => (t <= 0 ? 0 : 1 - Math.pow(1 - clamp(t, 0, 1), 3));
  const smoothstep = (t) => {
    const k = clamp(t, 0, 1);
    return k * k * (3 - 2 * k);
  };

  // === 自機ステート ===
  const player = {
    pos: { x: 0, y: 10, z: 40 }, // 後方から自機を見るためZを正にスタート
    vel: { x: 0, y: 0 },
    speedForward: 80,   // 高速感を保ちつつステージを長く感じさせるため速度を抑制
    roll: 0,
    maxHp: 120,
    hp: 120,
    maxShield: 60,
    shield: 60,
    maxStocks: 3,
    stocks: 3,
    invuln: 0,
    hitRadius: 6,
    visible: true, // ゲームオーバー時に自機を非表示にするためのフラグ
  };

  const camera = {
    pos: { x: 0, y: 18, z: 80 },
    targetOffset: { x: 0, y: -4, z: -40 },
    shake: 0,
  };

  // === シーンジオメトリ格納 ===
  const cityObjects = [];
  // === 敵オブジェクト格納 ===
  const enemyObjects = [];
  let simTime = 0; // シミュレーション経過時間（敵挙動の位相計算用）
  // === 投射物（プレイヤー・ミサイル・敵ショット）格納 ===
  const playerShots = [];
  const playerMissiles = [];
  const enemyShots = [];
  const explosions = [];
  const shieldPickups = [];
  let shotCooldown = 0;
  let missileCooldown = 0;
  const MISSILE_STOCK_MAX = Infinity; // ミサイルを無制限に扱うための疑似上限値
  const MAX_CONCURRENT_PLAYER_MISSILES = 4; // 同時発射可能な自機ミサイル数の上限
  const MISSILE_FIRE_INTERVAL = 0.4; // 連射間隔を短縮して同時発射を支援
  let missilesRemaining = MISSILE_STOCK_MAX;
  let missileRequest = false;
  const boss = {
    active: false,
    destroyed: false,
    spawnTriggerZ: -2400,
    pos: { x: 0, y: 4, z: -3200 },
    hp: 1200,
    maxHp: 1200,
    fireCooldown: 0,
    fireInterval: 1.1,
    shake: 0,
    edges: null,
    hitboxes: [],
    turretYaw: 0,
    type: "boss",
    variant: "tank",
    waveCharge: 0,
  };
  let stageClear = false;
  let stageClearTime = 0;
  let gameOver = false;
  let gameOverTime = 0;

  // === ゲームフェーズ管理 ===
  let gamePhase = "stage0";
  let phaseTime = 0;
  const stage0State = {
    startZ: 180,
    targetZ: 42,
    startY: 12,
    targetY: 10,
    doorProgress: 0,
    launchProgress: 0,
    thruster: 0,
  };
  const hangarScene = createHangarScene();
  const bossDistanceConstraint = {
    min: 380, // 自機とボスの最短距離（近接しすぎ防止）
    max: 520, // 自機弾が届く範囲を維持しつつ遠景シルエットを演出
  };
  const battleshipDistanceConstraint = {
    min: 540, // 戦艦の波動砲を視認しつつ被弾圏外に保つ距離
    max: 780,
  };
  let stage1Clear = false;
  const cityExitState = {
    progress: 0,
    duration: 9.0,
    passed: false,
  };
  const spaceScene = {
    objects: [],
    rings: [],
    stars: [],
    walkers: [],
    corridors: [],
    guideBeacons: [],
    guidePhase: 0,
    waveTimer: 0,
    waveInterval: 9.5,
  };
  let environment = "city";
  let skyMix = 0;

  // === ワイヤーフレームラインを投影して描画 ===
  function projectPointXYZ(px, py, pz) {
    const dx = px - camera.pos.x;
    const dy = py - camera.pos.y;
    const dz = pz - camera.pos.z;
    const z = -dz; // カメラ前方が-Zなので符号反転
    if (z < display.zNear || z > display.zFar) {
      return null;
    }
    const scale = display.fov / z;
    const halfHeight = canvas.height * 0.5;
    return {
      x: canvas.width * 0.5 + dx * scale * halfHeight,
      y: canvas.height * 0.5 - dy * scale * halfHeight,
      z,
    };
  }

  function projectPoint(ptOrX, y, z) {
    if (typeof ptOrX === "number") {
      return projectPointXYZ(ptOrX, y, z);
    }
    return projectPointXYZ(ptOrX.x, ptOrX.y, ptOrX.z);
  }

  // === ワイヤーフレームライン描画 ===
  function drawEdges(edges, color, width, glow, transform) {
    // transform指定時は平行移動＋ヨー回転をワンパス適用してGC削減
    ctx.lineWidth = width;
    ctx.strokeStyle = color;
    ctx.shadowColor = glow || color;
    ctx.shadowBlur = glow ? 18 : 0;
    ctx.beginPath();
    const hasTransform = Boolean(transform);
    const tx = hasTransform ? (transform.tx ?? transform.x ?? 0) : 0;
    const ty = hasTransform ? (transform.ty ?? transform.y ?? 0) : 0;
    const tz = hasTransform ? (transform.tz ?? transform.z ?? 0) : 0;
    const yaw = hasTransform ? (transform.yaw ?? 0) : 0;
    const cosYaw = yaw ? Math.cos(yaw) : 1;
    const sinYaw = yaw ? Math.sin(yaw) : 0;
    if (edges instanceof Float32Array) {
      for (let i = 0; i < edges.length; i += 6) {
        let ax = edges[i];
        let ay = edges[i + 1];
        let az = edges[i + 2];
        let bx = edges[i + 3];
        let by = edges[i + 4];
        let bz = edges[i + 5];
        if (yaw) {
          const rxA = ax * cosYaw + az * sinYaw;
          const rzA = -ax * sinYaw + az * cosYaw;
          const rxB = bx * cosYaw + bz * sinYaw;
          const rzB = -bx * sinYaw + bz * cosYaw;
          ax = rxA;
          az = rzA;
          bx = rxB;
          bz = rzB;
        }
        const pa = projectPointXYZ(ax + tx, ay + ty, az + tz);
        const pb = projectPointXYZ(bx + tx, by + ty, bz + tz);
        if (!pa || !pb) continue;
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
      }
    } else {
      for (let i = 0; i < edges.length; i++) {
        const edge = edges[i];
        let ax = edge[0].x;
        let ay = edge[0].y;
        let az = edge[0].z;
        let bx = edge[1].x;
        let by = edge[1].y;
        let bz = edge[1].z;
        if (yaw) {
          const rxA = ax * cosYaw + az * sinYaw;
          const rzA = -ax * sinYaw + az * cosYaw;
          const rxB = bx * cosYaw + bz * sinYaw;
          const rzB = -bx * sinYaw + bz * cosYaw;
          ax = rxA;
          az = rzA;
          bx = rxB;
          bz = rzB;
        }
        const pa = projectPointXYZ(ax + tx, ay + ty, az + tz);
        const pb = projectPointXYZ(bx + tx, by + ty, bz + tz);
        if (!pa || !pb) continue;
        ctx.moveTo(pa.x, pa.y);
        ctx.lineTo(pb.x, pb.y);
      }
    }
    ctx.stroke();
  }

  // === ステージ0ハンガーの描画 ===
  function drawStage0Hangar() {
    const glowBase = 0.55 + stage0State.launchProgress * 0.25;
    const doorOpen = stage0State.doorProgress;
    drawEdges(hangarScene.frame, `rgba(0, 90, 210, ${glowBase})`, 2.2, `rgba(0, 110, 255, ${glowBase})`);
    drawEdges(hangarScene.sideSupports, "rgba(0, 120, 255, 0.7)", 1.8, "rgba(0, 120, 255, 0.6)");
    drawEdges(hangarScene.ceilingBeams, "rgba(0, 150, 255, 0.75)", 1.6, "rgba(0, 150, 255, 0.6)");
    const floorAlpha = 0.45 + stage0State.thruster * 0.4;
    drawEdges(hangarScene.floorGrid, `rgba(0, 150, 255, ${floorAlpha})`, 1.2, `rgba(0, 120, 255, ${floorAlpha})`);
    const railGlow = 0.6 + stage0State.launchProgress * 0.3;
    drawEdges(hangarScene.walkwayRibs, `rgba(0, 200, 255, ${railGlow})`, 2.0, `rgba(0, 200, 255, ${railGlow})`);
    drawEdges(hangarScene.launchRails, `rgba(0, 255, 240, ${0.6 + stage0State.thruster * 0.5})`, 2.6, "rgba(0, 255, 240, 0.9)");
    const slide = 9 * doorOpen;
    drawEdges(hangarScene.doorLeft, `rgba(0, 180, 255, ${0.8 - doorOpen * 0.15})`, 2.6, "rgba(0, 180, 255, 0.8)", { tx: -slide });
    drawEdges(hangarScene.doorRight, `rgba(0, 180, 255, ${0.8 - doorOpen * 0.15})`, 2.6, "rgba(0, 180, 255, 0.8)", { tx: slide });
    drawEdges(hangarScene.exteriorRing, "rgba(0, 150, 255, 0.65)", 2.0, "rgba(0, 150, 255, 0.6)");
    drawEdges(hangarScene.towerAnchors, "rgba(0, 110, 220, 0.6)", 1.8, "rgba(0, 110, 220, 0.5)");
  }

  function drawStage0Thruster() {
    if (stage0State.thruster <= 0.001) return;
    const strength = stage0State.thruster;
    const tailLength = 10 + strength * 30;
    const base = {
      x: player.pos.x,
      y: player.pos.y,
      z: player.pos.z + 10,
    };
    const tail = {
      x: base.x,
      y: base.y - 1 - strength * 2,
      z: base.z + tailLength,
    };
    const head = projectPoint(base);
    const tip = projectPoint(tail);
    if (!head || !tip) return;
    ctx.save();
    ctx.lineWidth = 1.2 + strength * 6;
    ctx.strokeStyle = `rgba(0, 255, 255, ${0.75 + strength * 0.2})`;
    ctx.shadowColor = `rgba(0, 200, 255, ${0.9})`;
    ctx.shadowBlur = 24 + strength * 16;
    ctx.beginPath();
    ctx.moveTo(head.x, head.y);
    ctx.lineTo(tip.x, tip.y);
    ctx.stroke();
    ctx.restore();
  }

  // === ボックスエッジ生成（都市ビル用） ===
  function createBoxEdges(cx, cy, cz, w, h, d) {
    const x = w * 0.5;
    const y = h * 0.5;
    const z = d * 0.5;
    const pts = [
      { x: cx - x, y: cy - y, z: cz - z },
      { x: cx + x, y: cy - y, z: cz - z },
      { x: cx + x, y: cy + y, z: cz - z },
      { x: cx - x, y: cy + y, z: cz - z },
      { x: cx - x, y: cy - y, z: cz + z },
      { x: cx + x, y: cy - y, z: cz + z },
      { x: cx + x, y: cy + y, z: cz + z },
      { x: cx - x, y: cy + y, z: cz + z },
    ];
    const indices = [
      [0,1],[1,2],[2,3],[3,0],
      [4,5],[5,6],[6,7],[7,4],
      [0,4],[1,5],[2,6],[3,7],
    ];
    return indices.map(([a, b]) => [pts[a], pts[b]]);
  }

  // === ゲート構造生成 ===
  function createGateEdges(cx, cy, cz, w, h, d, thickness) {
    const edges = [];
    const half = thickness * 0.5;
    // フレームは四角形のリング
    const segments = [
      createBoxEdges(cx - (w * 0.5 - half), cy, cz, thickness, h, d),
      createBoxEdges(cx + (w * 0.5 - half), cy, cz, thickness, h, d),
      createBoxEdges(cx, cy + (h * 0.5 - half), cz, w - thickness * 2, thickness, d),
      createBoxEdges(cx, cy - (h * 0.5 - half), cz, w - thickness * 2, thickness, d),
    ];
    for (const seg of segments) edges.push(...seg);
    return edges;
  }

  // === グラウンドグリッド生成 ===
  function createGroundGrid(zStart, zEnd, step, widthSpan) {
    const edges = [];
    for (let z = zStart; z >= zEnd; z -= step) {
      edges.push([
        { x: -widthSpan, y: 0, z },
        { x: widthSpan, y: 0, z },
      ]);
    }
    for (let x = -widthSpan; x <= widthSpan; x += step) {
      edges.push([
        { x, y: 0, z: zStart },
        { x, y: 0, z: zEnd },
      ]);
    }
    return edges;
  }

  // === ステージ0用ハンガー形状生成 ===
  function createHangarScene() {
    const frame = createBoxEdges(0, 13, 150, 42, 28, 74);
    const sideSupports = [];
    for (const side of [-18, 18]) {
      for (let i = 0; i < 4; i++) {
        const z = 184 - i * 18;
        sideSupports.push(...createBoxEdges(side, 13, z, 2.4, 26, 6));
      }
    }
    const ceilingBeams = [];
    for (let i = 0; i <= 3; i++) {
      const z = 184 - i * 18;
      ceilingBeams.push(...createBoxEdges(0, 24, z, 36, 2, 2));
    }
    const floorGrid = [];
    const gridStart = 188;
    const gridEnd = 110;
    for (let z = gridStart; z >= gridEnd; z -= 6) {
      floorGrid.push([
        { x: -16, y: 0, z },
        { x: 16, y: 0, z },
      ]);
    }
    for (let x = -16; x <= 16; x += 4) {
      floorGrid.push([
        { x, y: 0, z: gridStart },
        { x, y: 0, z: gridEnd },
      ]);
    }
    const launchRails = [
      [{ x: -4.5, y: 1.4, z: 188 }, { x: -4.5, y: 1.4, z: 108 }],
      [{ x: 4.5, y: 1.4, z: 188 }, { x: 4.5, y: 1.4, z: 108 }],
      [{ x: -4.5, y: 1.4, z: 108 }, { x: -1.5, y: 5.2, z: 96 }],
      [{ x: 4.5, y: 1.4, z: 108 }, { x: 1.5, y: 5.2, z: 96 }],
    ];
    const walkwayRibs = [];
    for (let i = 0; i < 4; i++) {
      const z = 178 - i * 14;
      walkwayRibs.push(...createBoxEdges(0, 6, z, 24, 2.2, 4));
    }
    const doorLeft = createBoxEdges(-6, 13, 112, 10, 22, 3.2);
    const doorRight = createBoxEdges(6, 13, 112, 10, 22, 3.2);
    const exteriorRing = createBoxEdges(0, 24, 104, 38, 34, 6);
    const towerAnchors = [];
    towerAnchors.push(...createBoxEdges(-28, 20, 138, 4, 40, 78));
    towerAnchors.push(...createBoxEdges(28, 20, 138, 4, 40, 78));
    return {
      frame: edgesToFloat32(frame),
      sideSupports: edgesToFloat32(sideSupports),
      ceilingBeams: edgesToFloat32(ceilingBeams),
      floorGrid: edgesToFloat32(floorGrid),
      launchRails: edgesToFloat32(launchRails),
      walkwayRibs: edgesToFloat32(walkwayRibs),
      doorLeft: edgesToFloat32(doorLeft),
      doorRight: edgesToFloat32(doorRight),
      exteriorRing: edgesToFloat32(exteriorRing),
      towerAnchors: edgesToFloat32(towerAnchors),
    };
  }

  function createAsteroidCluster(cx, cy, cz, scale) {
    const pieces = [];
    const seeds = [
      { sx: 6, sy: 5, sz: 7, rx: 0.3, ry: 0.2, rz: 0.1, ox: 0, oy: 0, oz: 0 },
      { sx: 4, sy: 6, sz: 5, rx: -0.4, ry: 0.6, rz: 0.2, ox: 3, oy: 1.5, oz: -2 },
      { sx: 5, sy: 4, sz: 6, rx: 0.5, ry: -0.3, rz: -0.4, ox: -2.4, oy: -1.2, oz: 3.2 },
    ];
    for (const seed of seeds) {
      const base = createBoxEdges(0, 0, 0, seed.sx * scale, seed.sy * scale, seed.sz * scale);
      const rx = rotateEdgeListX(base, seed.rx);
      const rxy = rotateEdgeListY(rx, seed.ry);
      const rxyz = rotateEdgeListZ(rxy, seed.rz);
      pieces.push(...translateEdgeList(rxyz, cx + seed.ox * scale, cy + seed.oy * scale, cz + seed.oz * scale));
    }
    return pieces;
  }

  function createAsteroidRingEdges(cx, cy, cz, radius, thickness, segments) {
    const edges = [];
    for (let i = 0; i < segments; i++) {
      const a0 = (i / segments) * Math.PI * 2;
      const a1 = ((i + 1) / segments) * Math.PI * 2;
      const inner0 = { x: cx + Math.cos(a0) * (radius - thickness), y: cy + Math.sin(a0) * thickness * 0.3, z: cz + Math.sin(a0) * (radius - thickness) };
      const inner1 = { x: cx + Math.cos(a1) * (radius - thickness), y: cy + Math.sin(a1) * thickness * 0.3, z: cz + Math.sin(a1) * (radius - thickness) };
      const outer0 = { x: cx + Math.cos(a0) * (radius + thickness), y: cy + Math.sin(a0) * thickness * 0.6, z: cz + Math.sin(a0) * (radius + thickness) };
      const outer1 = { x: cx + Math.cos(a1) * (radius + thickness), y: cy + Math.sin(a1) * thickness * 0.6, z: cz + Math.sin(a1) * (radius + thickness) };
      edges.push([inner0, inner1]);
      edges.push([outer0, outer1]);
      edges.push([inner0, outer0]);
      edges.push([inner1, outer1]);
    }
    return edges;
  }

  function createSpaceCorridor(cx, cy, czStart, length, sections, halfWidth) {
    const edges = [];
    const step = length / sections;
    for (let i = 0; i < sections; i++) {
      const z0 = czStart - step * i;
      const z1 = z0 - step;
      const wobble = Math.sin((i / sections) * Math.PI * 2) * 4;
      const leftX = cx - halfWidth + wobble;
      const rightX = cx + halfWidth + wobble;
      const railY = cy + Math.sin((i * 0.8)) * 3;
      edges.push([
        { x: leftX, y: railY, z: z0 },
        { x: leftX, y: railY, z: z1 },
      ]);
      edges.push([
        { x: rightX, y: railY, z: z0 },
        { x: rightX, y: railY, z: z1 },
      ]);
      const crossCount = 3;
      for (let c = 1; c <= crossCount; c++) {
        const t = c / (crossCount + 1);
        const zCross = z0 + (z1 - z0) * t;
        const crossY = railY + Math.cos(t * Math.PI) * 2.4;
        edges.push([
          { x: leftX, y: crossY, z: zCross },
          { x: rightX, y: crossY, z: zCross },
        ]);
        edges.push([
          { x: cx, y: crossY - 6, z: zCross },
          { x: cx, y: crossY + 6, z: zCross },
        ]);
      }
    }
    return edges;
  }

  function generateStarField(count, spreadZ, offsetZ) {
    const stars = [];
    const baseZ = typeof offsetZ === "number" ? offsetZ : (player ? player.pos.z - 2000 : -2000);
    for (let i = 0; i < count; i++) {
      const x = (Math.random() * 2 - 1) * 240;
      const y = Math.random() * 220 + 40;
      const z = baseZ - Math.random() * spreadZ;
      stars.push({ x, y, z, twinkle: Math.random() * Math.PI * 2 });
    }
    return stars;
  }

  // === 辞書的なエッジ操作ユーティリティ ===
  function translateEdgeList(edges, dx, dy, dz) {
    return edges.map(([a, b]) => [
      { x: a.x + dx, y: a.y + dy, z: a.z + dz },
      { x: b.x + dx, y: b.y + dy, z: b.z + dz },
    ]);
  }

  function rotateEdgeListY(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ax = a.x * cosA + a.z * sinA;
      const az = -a.x * sinA + a.z * cosA;
      const bx = b.x * cosA + b.z * sinA;
      const bz = -b.x * sinA + b.z * cosA;
      return [
        { x: ax, y: a.y, z: az },
        { x: bx, y: b.y, z: bz },
      ];
    });
  }

  function rotateEdgeListX(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ay = a.y * cosA - a.z * sinA;
      const az = a.y * sinA + a.z * cosA;
      const by = b.y * cosA - b.z * sinA;
      const bz = b.y * sinA + b.z * cosA;
      return [
        { x: a.x, y: ay, z: az },
        { x: b.x, y: by, z: bz },
      ];
    });
  }

  function rotateEdgeListZ(edges, angle) {
    const cosA = Math.cos(angle);
    const sinA = Math.sin(angle);
    return edges.map(([a, b]) => {
      const ax = a.x * cosA - a.y * sinA;
      const ay = a.x * sinA + a.y * cosA;
      const bx = b.x * cosA - b.y * sinA;
      const by = b.x * sinA + b.y * cosA;
      return [
        { x: ax, y: ay, z: a.z },
        { x: bx, y: by, z: b.z },
      ];
    });
  }

  function edgesToFloat32(edges) {
    // エッジ配列をFloat32Arrayに格納して高速に走査できるようにする
    const buffer = new Float32Array(edges.length * 6);
    let p = 0;
    for (let i = 0; i < edges.length; i++) {
      const e = edges[i];
      const a = e[0];
      const b = e[1];
      buffer[p++] = a.x;
      buffer[p++] = a.y;
      buffer[p++] = a.z;
      buffer[p++] = b.x;
      buffer[p++] = b.y;
      buffer[p++] = b.z;
    }
    return buffer;
  }

  // === 敵シェイプ定義 ===
  function buildEnemyFighterShape() {
    // 小型戦闘機をローカル座標で定義（自機より短く薄い）
    return [
      [{ x: -6, y: 0, z: -3 }, { x: 6, y: 0, z: -3 }],
      [{ x: -3, y: 1.5, z: 0 }, { x: 0, y: -2, z: -10 }],
      [{ x: 3, y: 1.5, z: 0 }, { x: 0, y: -2, z: -10 }],
      [{ x: 0, y: -2, z: -10 }, { x: 0, y: 2.5, z: 4 }],
      [{ x: -2, y: 2.5, z: 4 }, { x: 2, y: 2.5, z: 4 }],
      [{ x: -1.5, y: -1, z: -6 }, { x: -1.5, y: 1, z: 2 }],
      [{ x: 1.5, y: -1, z: -6 }, { x: 1.5, y: 1, z: 2 }],
    ];
  }

  function buildGroundRobotShape() {
    // 二足歩行ロボを箱モジュールで表現
    const edges = [];
    edges.push(...createBoxEdges(0, 2.2, 0, 3.6, 4, 3)); // 胴体
    edges.push(...createBoxEdges(0, 4.6, -1.4, 2.8, 2.4, 2.4)); // 頭部
    edges.push(...createBoxEdges(-1.5, 0.8, 0, 1.2, 3.2, 1.2)); // 左脚
    edges.push(...createBoxEdges(1.5, 0.8, 0, 1.2, 3.2, 1.2)); // 右脚
    edges.push(...createBoxEdges(-2.4, 2.4, 0, 1.2, 1.2, 3.6)); // 左腕
    edges.push(...createBoxEdges(2.4, 2.4, 0, 1.2, 1.2, 3.6)); // 右腕
    return edges;
  }

  const enemyFighterShapeBase = buildEnemyFighterShape();
  const enemyFighterShape = edgesToFloat32(enemyFighterShapeBase);
  const enemyFighterShapeIncoming = edgesToFloat32(rotateEdgeListY(enemyFighterShapeBase, Math.PI));
  const enemyRobotShape = edgesToFloat32(buildGroundRobotShape());
  const bossTankShape = buildBossTank();

  function setupTankBoss() {
    boss.variant = "tank";
    boss.active = false;
    boss.destroyed = false;
    boss.spawnTriggerZ = -2400;
    boss.pos = { x: 0, y: 4, z: -3200 };
    boss.hp = 1200;
    boss.maxHp = 1200;
    boss.fireCooldown = 0;
    boss.fireInterval = 1.1;
    boss.shake = 0;
    boss.turretYaw = 0;
    boss.edges = bossTankShape.edges;
    boss.hitboxes = bossTankShape.hitboxes;
  }

  const spaceBattleshipShape = buildSpaceBattleship();

  function setupSpaceBattleship() {
    boss.variant = "battleship";
    boss.active = false;
    boss.destroyed = false;
    boss.spawnTriggerZ = -4200;
    boss.pos = { x: 0, y: 180, z: -5200 };
    boss.hp = 2600;
    boss.maxHp = 2600;
    boss.fireCooldown = 5.0;
    boss.fireInterval = 7.5;
    boss.waveCharge = 0;
    boss.shake = 0;
    boss.turretYaw = 0;
    boss.edges = spaceBattleshipShape.edges;
    boss.hitboxes = spaceBattleshipShape.hitboxes;
  }

  setupTankBoss();

  function buildSpaceBattleship() {
    // 宇宙戦艦ボス（遠距離から波動砲を放つ）
    const hull = createBoxEdges(0, 0, 0, 120, 18, 280);
    const bridge = createBoxEdges(0, 12, -42, 36, 20, 64);
    const fins = [
      ...createBoxEdges(-54, -6, 40, 28, 6, 160),
      ...createBoxEdges(54, -6, 40, 28, 6, 160),
    ];
    const cannon = createBoxEdges(0, 8, -180, 18, 6, 140);
    const antenna = createBoxEdges(0, 24, -20, 4, 28, 8);
    const engines = [
      ...createBoxEdges(-24, -6, 120, 28, 14, 40),
      ...createBoxEdges(24, -6, 120, 28, 14, 40),
    ];
    const edges = {
      base: edgesToFloat32(hull),
      bridge: edgesToFloat32(bridge),
      fins: edgesToFloat32(fins),
      cannon: edgesToFloat32(cannon),
      antenna: edgesToFloat32(antenna),
      engines: edgesToFloat32(engines),
    };
    const hitboxes = [
      { min: { x: -60, y: -10, z: -140 }, max: { x: 60, y: 14, z: 140 }, weight: 1.0 },
      { min: { x: -20, y: 0, z: -210 }, max: { x: 20, y: 16, z: -80 }, weight: 1.4 },
      { min: { x: -32, y: -8, z: 90 }, max: { x: 32, y: 8, z: 150 }, weight: 1.2 },
    ];
    return { edges, hitboxes };
  }

  function buildBossTank() {
    // 巨大戦車ボス（ビル街の終端に鎮座）
    const base = createBoxEdges(0, 2.5, 0, 52, 6, 82);
    const hull = createBoxEdges(0, 8, -6, 42, 8, 52);
    const turret = createBoxEdges(0, 12, -10, 28, 6, 36);
    const cannon = createBoxEdges(0, 12, -46, 6, 4, 60);
    const leftTread = createBoxEdges(-26, 2, 0, 8, 6, 90);
    const rightTread = createBoxEdges(26, 2, 0, 8, 6, 90);
    const antenna = createBoxEdges(10, 16, -4, 2, 10, 2);
    const edges = {
      base: edgesToFloat32(base),
      hull: edgesToFloat32(hull),
      turret: edgesToFloat32(turret),
      cannon: edgesToFloat32(cannon),
      treads: edgesToFloat32([...leftTread, ...rightTread]),
      antenna: edgesToFloat32(antenna),
    };
    const hitboxes = [
      { min: { x: -26, y: 0, z: -45 }, max: { x: 26, y: 12, z: 35 }, weight: 1.0 },
      { min: { x: -16, y: 8, z: -50 }, max: { x: 16, y: 16, z: -8 }, weight: 1.2 }, // 砲塔
      { min: { x: -4, y: 9, z: -86 }, max: { x: 4, y: 15, z: -36 }, weight: 1.5 }, // 砲身
    ];
    return { edges, hitboxes };
  }

  // === 敵の現在位置を取得（射撃や誘導用） ===
  function getEnemyPose(enemy) {
    if (!enemy) return null;
    if (enemy === boss || enemy.type === "boss") {
      if (boss.variant === "battleship") {
        return { x: boss.pos.x, y: boss.pos.y + 6, z: boss.pos.z - 140 };
      }
      // 戦車ボス（都市ステージ）のターゲット座標
      return { x: boss.pos.x, y: boss.pos.y + 8, z: boss.pos.z - 16 };
    }
    if (!enemy.base) return null;
    const freq = enemy.frequency || 1.0;
    const phase = enemy.phase || 0;
    const wave = Math.sin(simTime * freq + phase);
    const sway = Math.cos(simTime * freq * (enemy.type === "incoming" ? 0.6 : 0.7) + phase);
    let x = enemy.pathCenterX ?? enemy.base.x ?? 0;
    let y = enemy.base.y;
    let z = enemy.base.z;
    if (enemy.type === "air") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y += sway * (enemy.amplitudeY || 0);
    } else if (enemy.type === "ground") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y = Math.max(1.2, enemy.base.y + Math.abs(wave) * 1.2);
    } else if (enemy.type === "incoming") {
      x = (enemy.pathCenterX ?? 0) + wave * (enemy.amplitudeX || 0);
      y += sway * (enemy.amplitudeY || 0);
    } else if (enemy.type === "pursuer") {
      x = (enemy.base.x ?? 0) + wave * (enemy.amplitudeX || 0);
      y = (enemy.base.y ?? 0) + sway * (enemy.amplitudeY || 0);
    }
    x = clamp(x, -36, 36);
    return { x, y, z };
  }

  // === プレイヤー武装ユーティリティ ===
  function spawnPlayerShot() {
    const speed = 420;
    const muzzles = [
      { x: -1.6, y: -0.8, z: -6 },
      { x: 1.6, y: -0.8, z: -6 },
    ];
    audioSystem.playLaserShot(); // レーザー発射音を再生
    muzzles.forEach((off) => {
      // 自機レーザーの発光パラメータを付与
      playerShots.push({
        pos: { x: player.pos.x + off.x, y: player.pos.y + off.y, z: player.pos.z + off.z },
        vel: { x: off.x * 6, y: off.y * 4, z: -speed },
        ttl: 1.4,
        lifeMax: 1.4,
        beam: true,
        beamLength: 0.28,
        width: 3.6,
        color: "rgba(0, 255, 255, 0.9)",
        glowStart: "rgba(0, 200, 255, 0.55)",
        glowEnd: "rgba(0, 120, 255, 0.05)",
        coreColor: "rgba(255, 255, 255, 0.95)",
        shadowColor: "rgba(0, 180, 255, 0.85)",
        spawnTime: performance.now(),
        pulseSpeed: 8.0,
        pulseRange: 0.2,
        pulseOffset: Math.random() * Math.PI * 2,
      });
    });
  }

  function acquireMissileTarget() {
    let best = null;
    let bestScore = Infinity;
    const consider = (pose, ref, weight = 1.0) => {
      if (!pose) return;
      if (pose.z > player.pos.z + 40) return;
      const dz = player.pos.z - pose.z;
      if (dz < 20) return;
      const dx = player.pos.x - pose.x;
      const dy = player.pos.y - pose.y;
      const lateral = Math.hypot(dx, dy);
      const score = lateral * weight + dz * 0.35;
      if (score < bestScore) {
        bestScore = score;
        best = ref;
      }
    };
    for (const enemy of enemyObjects) {
      if (!enemy) continue;
      if (enemy.type === "ground") continue;
      const pose = getEnemyPose(enemy);
      consider(pose, enemy, enemy.type === "pursuer" ? 0.7 : 1.0);
    }
    if (boss.active && !boss.destroyed) {
      const bossPose = { x: boss.pos.x, y: boss.pos.y + 6, z: boss.pos.z - 20 };
      consider(bossPose, boss, 0.6);
    }
    return best;
  }

  function spawnPlayerMissile() {
    if (missileCooldown > 0) return;
    if (playerMissiles.length >= MAX_CONCURRENT_PLAYER_MISSILES) {
      // 画面上のミサイル数が上限に達している場合は追加発射しない
      return;
    }
    const target = acquireMissileTarget();
    if (!target) return;
    missilesRemaining -= 1;
    missileCooldown = MISSILE_FIRE_INTERVAL;
    const spawn = { x: player.pos.x, y: player.pos.y - 1.5, z: player.pos.z - 8 };
    playerMissiles.push({
      pos: { ...spawn },
      vel: { x: 0, y: 0, z: -140 },
      speed: 170,
      ttl: 6.0,
      target,
      turnRate: 4.0,
      trail: [],
    });
  }

  function spawnEnemyShot(enemy) {
    if (typeof enemy.hp === "number" && enemy.hp <= 0) return;
    const pose = getEnemyPose(enemy);
    if (!pose) return;
    const dx = player.pos.x - pose.x;
    const dy = player.pos.y - pose.y;
    const dz = player.pos.z - pose.z;
    const dist = Math.hypot(dx, dy, dz);
    if (dist < 1e-3) return;
    const isGround = enemy.type === "ground" || enemy.type === "walker";
    const speed = isGround ? 260 : 300;
    const vx = (dx / dist) * speed;
    const vy = (dy / dist) * speed;
    const vz = (dz / dist) * speed;
    // 敵ショットもレーザー光として強調
    enemyShots.push({
      pos: { x: pose.x, y: pose.y, z: pose.z },
      vel: { x: vx, y: vy, z: vz },
      ttl: isGround ? 2.4 : 2.0,
      lifeMax: isGround ? 2.4 : 2.0,
      beam: true,
      beamLength: isGround ? 0.22 : 0.3,
      width: isGround ? 2.8 : 3.2,
      color: "rgba(255, 110, 150, 0.9)",
      glowStart: "rgba(255, 70, 120, 0.55)",
      glowEnd: "rgba(255, 20, 60, 0.05)",
      coreColor: "rgba(255, 255, 255, 0.9)",
      shadowColor: "rgba(255, 90, 160, 0.85)",
      spawnTime: performance.now(),
      pulseSpeed: 6.4,
      pulseRange: 0.16,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: enemy.shotDamage || (isGround ? 18 : 14),
      hitRadius: isGround ? 7 : 8,
    });
  }

  function updatePlayerWeapons(dt) {
    shotCooldown = Math.max(0, shotCooldown - dt);
    missileCooldown = Math.max(0, missileCooldown - dt);
    if (keys.has("Space") && shotCooldown <= 0) {
      spawnPlayerShot();
      shotCooldown = 0.12;
    }
    if (missileRequest) {
      spawnPlayerMissile();
    }
    missileRequest = false;
  }

  function updateProjectiles(dt) {
    // レーザー進行
    for (let i = playerShots.length - 1; i >= 0; i--) {
      const shot = playerShots[i];
      if (!shot) {
        playerShots.splice(i, 1);
        continue;
      }
      shot.pos.x += shot.vel.x * dt;
      shot.pos.y += shot.vel.y * dt;
      shot.pos.z += shot.vel.z * dt;
      shot.ttl -= dt;
      if (boss.active && !boss.destroyed) {
        const weight = pointInsideBoss(shot.pos.x, shot.pos.y, shot.pos.z);
        if (weight) {
          spawnExplosion(shot.pos.x, shot.pos.y, shot.pos.z, 0.9, 0.4);
          applyBossDamage(18 * weight);
          playerShots.splice(i, 1);
          continue;
        }
      }
      let enemyHit = false;
      for (let j = enemyObjects.length - 1; j >= 0; j--) {
        const enemy = enemyObjects[j];
        if (!enemy || typeof enemy.hp !== "number") continue;
        const pose = getEnemyPose(enemy);
        if (!pose) continue;
        const dx = pose.x - shot.pos.x;
        const dy = pose.y - shot.pos.y;
        const dz = pose.z - shot.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        if (dist <= (enemy.hitRadius || 8)) {
          applyEnemyDamage(j, 30);
          playerShots.splice(i, 1);
          enemyHit = true;
          break;
        }
      }
      if (enemyHit) {
        continue;
      }
      if (shot.ttl <= 0 || shot.pos.z < player.pos.z - 900) {
        playerShots.splice(i, 1);
      }
    }
    // ミサイル誘導
    for (let i = playerMissiles.length - 1; i >= 0; i--) {
      const missile = playerMissiles[i];
      if (!missile) {
        playerMissiles.splice(i, 1);
        continue;
      }
      const target = missile.target;
      if (target) {
        const pose = getEnemyPose(target);
        if (pose && !(target === boss && boss.destroyed)) {
          const dx = pose.x - missile.pos.x;
          const dy = pose.y - missile.pos.y;
          const dz = pose.z - missile.pos.z;
          const dist = Math.hypot(dx, dy, dz);
          if (dist > 1e-3) {
            const desired = { x: dx / dist, y: dy / dist, z: dz / dist };
            missile.vel.x += (desired.x * missile.speed - missile.vel.x) * Math.min(1, dt * missile.turnRate);
            missile.vel.y += (desired.y * missile.speed - missile.vel.y) * Math.min(1, dt * missile.turnRate);
            missile.vel.z += (desired.z * missile.speed - missile.vel.z) * Math.min(1, dt * missile.turnRate);
          }
        } else {
          missile.target = null;
        }
      }
      missile.pos.x += missile.vel.x * dt;
      missile.pos.y += missile.vel.y * dt;
      missile.pos.z += missile.vel.z * dt;
      const trail = missile.trail || (missile.trail = []);
      const jitterX = (Math.random() - 0.5) * 1.2;
      const jitterY = (Math.random() - 0.5) * 0.7;
      const jitterZ = (Math.random() - 0.5) * 1.2;
      trail.push({
        x: missile.pos.x + jitterX,
        y: missile.pos.y + jitterY,
        z: missile.pos.z + jitterZ,
      });
      if (trail.length > 48) {
        trail.shift();
      }
      missile.ttl -= dt;
      if (boss.active && !boss.destroyed) {
        const weight = pointInsideBoss(missile.pos.x, missile.pos.y, missile.pos.z);
        if (weight) {
          spawnExplosion(missile.pos.x, missile.pos.y, missile.pos.z, 2.0, 0.6);
          applyBossDamage(160 * weight);
          playerMissiles.splice(i, 1);
          continue;
        }
      }
      let missileEnemyHit = false;
      for (let j = enemyObjects.length - 1; j >= 0; j--) {
        const enemy = enemyObjects[j];
        if (!enemy || typeof enemy.hp !== "number") continue;
        const pose = getEnemyPose(enemy);
        if (!pose) continue;
        const dx = pose.x - missile.pos.x;
        const dy = pose.y - missile.pos.y;
        const dz = pose.z - missile.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        if (dist <= (enemy.hitRadius ? enemy.hitRadius + 4 : 14)) {
          applyEnemyDamage(j, 220);
          playerMissiles.splice(i, 1);
          missileEnemyHit = true;
          break;
        }
      }
      if (missileEnemyHit) {
        continue;
      }
      if (missile.ttl <= 0 || missile.pos.z < player.pos.z - 1000) {
        playerMissiles.splice(i, 1);
      }
    }
    // 敵ショット進行
    for (let i = enemyShots.length - 1; i >= 0; i--) {
      const shot = enemyShots[i];
      if (!shot) {
        enemyShots.splice(i, 1);
        continue;
      }
      shot.pos.x += shot.vel.x * dt;
      shot.pos.y += shot.vel.y * dt;
      shot.pos.z += shot.vel.z * dt;
      shot.ttl -= dt;
      if (gamePhase !== "stage0" && gamePhase !== "gameOver") {
        const dx = shot.pos.x - player.pos.x;
        const dy = shot.pos.y - player.pos.y;
        const dz = shot.pos.z - player.pos.z;
        const dist = Math.hypot(dx, dy, dz);
        const hitRange = shot.hitRadius || (player.hitRadius + 3);
        if (dist <= hitRange) {
          applyPlayerDamage(shot.damage || 12, shot);
          enemyShots.splice(i, 1);
          continue;
        }
      }
      if (shot.ttl <= 0 || shot.pos.z > player.pos.z + 200 || shot.pos.z < player.pos.z - 1000) {
        enemyShots.splice(i, 1);
      }
    }
  }

  function drawLaserProjectiles(list, defaultColor, width, lengthScale) {
    if (!list.length) return;
    ctx.save();
    const now = performance.now();
    ctx.globalCompositeOperation = "lighter";
    ctx.lineCap = "round";
    for (const shot of list) {
      const head = projectPoint(shot.pos);
      if (!head) continue;
      const len = shot.beam ? (shot.beamLength || lengthScale * 2.6) : lengthScale;
      const tailPoint = {
        x: shot.pos.x - shot.vel.x * len,
        y: shot.pos.y - shot.vel.y * len,
        z: shot.pos.z - shot.vel.z * len,
      };
      const tail = projectPoint(tailPoint);
      if (!tail) continue;

      const baseColor = shot.color || defaultColor;
      const glowStart = shot.glowStart || baseColor;
      const glowEnd = shot.glowEnd || "rgba(0, 0, 0, 0)";
      const coreColor = shot.coreColor || "rgba(255, 255, 255, 0.9)";
      const pulseSpeed = shot.pulseSpeed || 0;
      const pulseRange = shot.pulseRange || 0;
      const pulseOffset = shot.pulseOffset || 0;
      const lifeMax = shot.lifeMax || shot.ttl || 1;
      const lifeRatio = Math.max(0, Math.min(1, (shot.ttl ?? lifeMax) / lifeMax));
      const elapsed = now - (shot.spawnTime || now);
      const pulseFactor = 1 + (pulseSpeed ? Math.sin(elapsed * 0.001 * pulseSpeed + pulseOffset) * pulseRange : 0);
      const beamWidth = (shot.width || width) * pulseFactor * (0.7 + lifeRatio * 0.6);

      // レーザー外縁の発光グラデーションを描画
      const glowGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
      glowGradient.addColorStop(0, glowStart);
      glowGradient.addColorStop(0.45, baseColor);
      glowGradient.addColorStop(1, glowEnd);
      ctx.shadowColor = shot.shadowColor || glowStart;
      ctx.shadowBlur = (shot.beam ? 32 : 16) * pulseFactor * (0.6 + lifeRatio * 0.5);
      ctx.lineWidth = beamWidth * (shot.beam ? 1.6 : 1.1);
      ctx.strokeStyle = glowGradient;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      // レーザー中心の熱量を細いコアとして重ね書き
      const coreGradient = ctx.createLinearGradient(head.x, head.y, tail.x, tail.y);
      coreGradient.addColorStop(0, coreColor);
      coreGradient.addColorStop(1, "rgba(255, 255, 255, 0.18)");
      ctx.shadowBlur = (shot.beam ? 20 : 10) * pulseFactor * (0.5 + lifeRatio * 0.5);
      ctx.lineWidth = beamWidth * 0.65;
      ctx.strokeStyle = coreGradient;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.lineWidth = Math.max(0.9, beamWidth * 0.28);
      ctx.strokeStyle = coreColor;
      ctx.beginPath();
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
      ctx.stroke();

      // 着弾点の閃光を小さな円で付与
      ctx.shadowColor = shot.shadowColor || baseColor;
      ctx.shadowBlur = 14 * pulseFactor;
      ctx.fillStyle = coreColor;
      ctx.beginPath();
      ctx.arc(head.x, head.y, Math.max(1.2, beamWidth * 0.5), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    ctx.restore();
  }

  // === ミサイル描画 ===
  function drawMissiles(list) {
    if (!list.length) return;
    ctx.save();
    for (const missile of list) {
      const trail = missile.trail;
      if (trail && trail.length >= 2) {
        for (let i = 1; i < trail.length; i++) {
          const prev = projectPoint(trail[i - 1]);
          const curr = projectPoint(trail[i]);
          if (!prev || !curr) continue;
          const t = 1 - i / trail.length;
          ctx.lineWidth = 1.2 + t * 2.8;
          ctx.strokeStyle = `rgba(60, 140, 255, ${0.04 + t * 0.22})`;
          ctx.shadowColor = `rgba(40, 120, 255, ${0.24 * t})`;
          ctx.shadowBlur = 12 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();

          ctx.lineWidth = 0.8 + t * 1.6;
          ctx.strokeStyle = `rgba(140, 220, 255, ${0.06 + t * 0.32})`;
          ctx.shadowColor = `rgba(80, 200, 255, ${0.18 * t})`;
          ctx.shadowBlur = 16 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();

          ctx.lineWidth = 0.4 + t * 0.9;
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.04 + t * 0.2})`;
          ctx.shadowColor = `rgba(200, 255, 255, ${0.14 * t})`;
          ctx.shadowBlur = 8 * t;
          ctx.beginPath();
          ctx.moveTo(prev.x, prev.y);
          ctx.lineTo(curr.x, curr.y);
          ctx.stroke();
        }
      }
    }

    ctx.lineWidth = 2.6;
    ctx.strokeStyle = "rgba(255, 200, 120, 0.95)";
    ctx.shadowColor = "rgba(255, 180, 100, 0.9)";
    ctx.shadowBlur = 18;
    ctx.beginPath();
    for (const missile of list) {
      const head = projectPoint(missile.pos);
      if (!head) continue;
      const tailPos = {
        x: missile.pos.x - missile.vel.x * 0.03,
        y: missile.pos.y - missile.vel.y * 0.03,
        z: missile.pos.z - missile.vel.z * 0.03,
      };
      const tail = projectPoint(tailPos);
      if (!tail) continue;
      ctx.moveTo(head.x, head.y);
      ctx.lineTo(tail.x, tail.y);
    }
    ctx.stroke();
    ctx.restore();
  }

  function drawPlayerStatusOverlay(hpText, shieldText, stockText) {
    const scale = Math.max(canvas.width / 1280, canvas.height / 720);
    const panelWidth = canvas.width * 0.22;
    const barHeight = 10 * scale;
    const gap = 14 * scale;
    const baseX = 32 * scale;
    const baseY = canvas.height - 70 * scale;
    const hpRatio = player.maxHp > 0 ? clamp(player.hp / player.maxHp, 0, 1) : 0;
    const shieldRatio = player.maxShield > 0 ? clamp(player.shield / player.maxShield, 0, 1) : 0;
    const panelHeight = 96 * scale;
    ctx.save();
    ctx.globalAlpha = 0.92;
    ctx.fillStyle = "rgba(4, 12, 28, 0.7)";
    ctx.fillRect(baseX - 14 * scale, baseY - 32 * scale, panelWidth + 28 * scale, panelHeight);
    ctx.strokeStyle = "rgba(0, 120, 255, 0.6)";
    ctx.lineWidth = 1.4 * scale;
    ctx.strokeRect(baseX - 14 * scale, baseY - 32 * scale, panelWidth + 28 * scale, panelHeight);

    ctx.fillStyle = "rgba(0, 255, 220, 0.18)";
    ctx.fillRect(baseX, baseY - gap, panelWidth, barHeight);
    ctx.fillStyle = "rgba(0, 255, 220, 0.85)";
    ctx.fillRect(baseX, baseY - gap, panelWidth * hpRatio, barHeight);

    ctx.fillStyle = "rgba(0, 180, 255, 0.16)";
    ctx.fillRect(baseX, baseY + barHeight * 0.6, panelWidth, barHeight);
    ctx.fillStyle = "rgba(0, 180, 255, 0.82)";
    ctx.fillRect(baseX, baseY + barHeight * 0.6, panelWidth * shieldRatio, barHeight);

    ctx.fillStyle = "rgba(200, 240, 255, 0.88)";
    ctx.font = `${14 * scale}px "Helvetica Neue", system-ui, sans-serif`;
    ctx.textBaseline = "bottom";
    ctx.fillText(hpText, baseX, baseY - gap - 4 * scale);
    ctx.textBaseline = "top";
    ctx.fillText(shieldText, baseX, baseY + barHeight * 0.6 + 4 * scale);
    ctx.fillText(stockText, baseX, baseY + barHeight * 1.9 + 4 * scale);
    ctx.restore();
  }

  // === 星背景描画 ===
  function drawStars(alpha) {
    if (!spaceScene.stars.length || alpha <= 0.01) return;
    ctx.save();
    ctx.shadowBlur = 0;
    for (const star of spaceScene.stars) {
      const projected = projectPoint(star);
      if (!projected) continue;
      const pulse = 0.5 + Math.sin(star.twinkle + simTime * 2.0) * 0.5;
      const brightness = (0.25 + 0.75 * pulse) * alpha;
      ctx.fillStyle = `rgba(140, 210, 255, ${0.18 + 0.42 * brightness})`;
      ctx.beginPath();
      ctx.arc(projected.x, projected.y, 0.8 + brightness * 1.6, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // === 宇宙環境（アステロイド等）描画 ===
  function drawSpaceScenery(alpha) {
    if (alpha <= 0.01) return;
    for (const obj of spaceScene.objects) {
      if (obj.type === "platform") {
        drawEdges(obj.edges, `rgba(0, 220, 255, ${0.42 * alpha})`, 2.0, `rgba(0, 255, 255, ${0.36 * alpha})`);
      } else {
        drawEdges(obj.edges, `rgba(0, 150, 255, ${0.26 * alpha})`, 1.6, `rgba(0, 120, 255, ${0.22 * alpha})`);
      }
    }
    for (const corridor of spaceScene.corridors) {
      drawEdges(corridor.edges, `rgba(0, 255, 245, ${0.42 * alpha})`, 2.8, `rgba(0, 255, 230, ${0.48 * alpha})`);
    }
    for (const ring of spaceScene.rings) {
      drawEdges(ring.edges, `rgba(0, 255, 230, ${0.5 * alpha})`, 3.0, `rgba(0, 255, 200, ${0.55 * alpha})`);
    }
  }

  function drawGuideBeacons(alpha) {
    if (!spaceScene.guideBeacons.length || alpha <= 0.01) return;
    ctx.save();
    for (const beacon of spaceScene.guideBeacons) {
      const pulse = 0.6 + Math.sin(spaceScene.guidePhase + beacon.phase) * 0.4;
      const proj = projectPoint(beacon);
      if (!proj) continue;
      const radius = 4 + pulse * 3;
      ctx.fillStyle = `rgba(0, 255, 255, ${0.25 * alpha + pulse * 0.2})`;
      ctx.shadowColor = `rgba(0, 200, 255, ${0.55 * alpha})`;
      ctx.shadowBlur = 28 * alpha * pulse;
      ctx.beginPath();
      ctx.arc(proj.x, proj.y, radius, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }
  function getBossEdgeGroups() {
    if (!boss.active && !boss.destroyed) return null;
    const offset = boss.pos;
    const shake = boss.shake || 0;
    const sx = (Math.random() - 0.5) * shake * 0.4;
    const sy = (Math.random() - 0.5) * shake * 0.2;
    const sz = (Math.random() - 0.5) * shake * 0.3;
    const baseTransform = { tx: offset.x + sx, ty: offset.y + sy, tz: offset.z + sz };
    if (boss.variant === "battleship") {
      const yaw = boss.turretYaw || 0;
      const yawTransform = { ...baseTransform, yaw };
      return {
        variant: "battleship",
        base: { edges: boss.edges.base, transform: baseTransform },
        bridge: { edges: boss.edges.bridge, transform: baseTransform },
        fins: { edges: boss.edges.fins, transform: baseTransform },
        engines: { edges: boss.edges.engines, transform: baseTransform },
        cannon: { edges: boss.edges.cannon, transform: yawTransform },
        antenna: { edges: boss.edges.antenna, transform: yawTransform },
      };
    }
    const yaw = boss.turretYaw || 0;
    const yawTransform = { ...baseTransform, yaw };
    return {
      variant: "tank",
      base: { edges: boss.edges.base, transform: baseTransform },
      hull: { edges: boss.edges.hull, transform: baseTransform },
      treads: { edges: boss.edges.treads, transform: baseTransform },
      turret: { edges: boss.edges.turret, transform: yawTransform },
      cannon: { edges: boss.edges.cannon, transform: yawTransform },
      antenna: { edges: boss.edges.antenna, transform: yawTransform },
    };
  }

  function pointInsideBoss(px, py, pz) {
    if (!boss.active || boss.destroyed) return false;
    const lx = px - boss.pos.x;
    const ly = py - boss.pos.y;
    const lz = pz - boss.pos.z;
    for (const hb of boss.hitboxes) {
      if (lx >= hb.min.x && lx <= hb.max.x &&
          ly >= hb.min.y && ly <= hb.max.y &&
          lz >= hb.min.z && lz <= hb.max.z) {
        return hb.weight || 1.0;
      }
    }
    return 0;
  }

  function applyBossDamage(amount) {
    if (!boss.active || boss.destroyed) return;
    boss.hp = Math.max(0, boss.hp - amount);
    boss.shake = 0.6;
    if (boss.hp <= 0) {
      boss.destroyed = true;
      enemyShots.length = 0;
      if (boss.variant === "battleship") {
        for (let i = 0; i < 14; i++) {
          const ox = (Math.random() - 0.5) * 90;
          const oy = Math.random() * 50 - 10;
          const oz = (Math.random() - 0.5) * 160;
          spawnExplosion(boss.pos.x + ox, boss.pos.y + oy, boss.pos.z + oz, 5.4, 1.6);
        }
        triggerFinalVictory();
      } else {
        for (let i = 0; i < 8; i++) {
          const ox = (Math.random() - 0.5) * 24;
          const oy = Math.random() * 10 + 4;
          const oz = (Math.random() - 0.5) * 28;
          spawnExplosion(boss.pos.x + ox, boss.pos.y + oy, boss.pos.z + oz, 3.2, 1.1);
        }
        triggerCityBossDefeat();
      }
    }
  }

  // === シティボス撃破処理 ===
  function triggerCityBossDefeat() {
    stage1Clear = true;
    gamePhase = "cityExit";
    phaseTime = 0;
    cityExitState.progress = 0;
    cityExitState.passed = false;
    enemyObjects.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    shieldPickups.length = 0;
  }

  // === 最終撃破処理 ===
  function triggerFinalVictory() {
    stageClear = true;
    stageClearTime = performance.now();
    gamePhase = "finalClear";
    phaseTime = 0;
    enemyObjects.length = 0;
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    shieldPickups.length = 0;
  }

  function applyEnemyDamage(enemyIndex, amount) {
    const enemy = enemyObjects[enemyIndex];
    if (!enemy) return false;
    if (typeof enemy.hp !== "number") return false;
    enemy.hp = Math.max(0, enemy.hp - amount);
    enemy.hitFlash = 0.45;
    if (enemy.hp <= 0) {
      const pose = getEnemyPose(enemy);
      if (pose) {
        spawnExplosion(pose.x, pose.y, pose.z, 1.2, 0.7);
        if (enemy.dropShield) {
          spawnShieldPickup(pose.x, pose.y, pose.z, enemy.shieldReward || 35);
        }
      }
      enemyObjects.splice(enemyIndex, 1);
      return true;
    }
    return false;
  }

  function applyPlayerDamage(amount, source) {
    if (stageClear || gamePhase === "stage0" || gamePhase === "finalClear" || gamePhase === "gameOver") return;
    if (player.invuln > 0) return;
    let remaining = amount;
    if (player.shield > 0) {
      const absorbed = Math.min(player.shield, remaining);
      player.shield -= absorbed;
      remaining -= absorbed;
    }
    if (remaining > 0) {
      player.hp = Math.max(0, player.hp - remaining);
    }
    const explosionScale = Math.min(1.8, 0.6 + amount * 0.02);
    spawnExplosion(player.pos.x, player.pos.y, player.pos.z - 6, explosionScale, 0.45 + amount * 0.01);
    camera.shake = Math.max(camera.shake, 0.9);
    player.invuln = 0.9;
    if (player.hp <= 0) {
      handlePlayerLifeLoss();
    }
  }

  function handlePlayerLifeLoss() {
    player.stocks = Math.max(0, player.stocks - 1);
    if (player.stocks > 0) {
      respawnPlayer();
    } else {
      triggerPlayerGameOver();
    }
  }

  function triggerPlayerGameOver() {
    if (gameOver) return;
    gameOver = true;
    gameOverTime = performance.now();
    gamePhase = "gameOver";
    phaseTime = 0;
    stageClear = false;
    stage1Clear = false;
    missilesRemaining = MISSILE_STOCK_MAX;
    player.stocks = 0;
    player.hp = 0;
    player.shield = 0;
    player.invuln = 2.0;
    player.visible = false; // 自機を非表示にしてゲームオーバー演出を明確化
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    enemyObjects.length = 0;
    shieldPickups.length = 0;
    for (let i = 0; i < 6; i++) {
      const ox = (Math.random() - 0.5) * 14;
      const oy = Math.random() * 8;
      const oz = (Math.random() - 0.5) * 12 - 6;
      spawnExplosion(player.pos.x + ox, player.pos.y + oy, player.pos.z + oz, 2 + i * 0.45, 0.6 + i * 0.12);
    }
  }

  function spawnExplosion(x, y, z, scale = 1.0, duration = 0.7) {
    audioSystem.playExplosion(scale); // 爆発規模に応じた効果音を再生
    const count = 18;
    const shards = [];
    for (let i = 0; i < count; i++) {
      let vx = Math.random() * 2 - 1;
      let vy = Math.random() * 2 - 1;
      let vz = Math.random() * 2 - 1;
      const mag = Math.hypot(vx, vy, vz) || 1;
      vx /= mag;
      vy /= mag;
      vz /= mag;
      const len = (0.6 + Math.random() * 0.6) * scale;
      shards.push({ dir: { x: vx, y: vy, z: vz }, len });
    }
    const rings = [];
    for (let r = 0; r < 3; r++) {
      rings.push({
        baseRadius: scale * (0.7 + r * 0.55) * (0.8 + Math.random() * 0.4),
        tilt: (Math.random() * Math.PI) - Math.PI / 2,
        height: (Math.random() * 1.4 - 0.2) * scale,
      });
    }
    explosions.push({ pos: { x, y, z }, shards, rings, age: 0, duration, scale });
  }

  // === シールド回復アイテム生成 ===
  function spawnShieldPickup(x, y, z, amount) {
    // 敵撃破時に出現するシールド補給カプセルを蓄積
    const baseY = y;
    shieldPickups.push({
      pos: { x, y, z },
      baseY,
      amount,
      phase: Math.random() * Math.PI * 2,
      ttl: 9.0,
      radius: 10,
    });
  }

  // === シールド回復アイテム更新 ===
  function updateShieldPickups(dt) {
    if (!shieldPickups.length) return;
    for (let i = shieldPickups.length - 1; i >= 0; i--) {
      const pickup = shieldPickups[i];
      pickup.ttl -= dt;
      pickup.phase = (pickup.phase + dt * 2.6) % (Math.PI * 2);
      pickup.pos.y = (pickup.baseY ?? pickup.pos.y) + Math.sin(pickup.phase * 3) * 4;
      if (pickup.ttl <= 0 || pickup.pos.z > player.pos.z + 80) {
        shieldPickups.splice(i, 1);
        continue;
      }
      const dx = player.pos.x - pickup.pos.x;
      const dy = player.pos.y - pickup.pos.y;
      const dz = player.pos.z - pickup.pos.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= pickup.radius + player.hitRadius) {
        // シールドを回復してドロップを消滅させる
        player.shield = Math.min(player.maxShield, player.shield + pickup.amount);
        player.invuln = Math.max(player.invuln, 0.4);
        spawnExplosion(pickup.pos.x, pickup.pos.y, pickup.pos.z, 0.8, 0.4);
        shieldPickups.splice(i, 1);
      }
    }
  }

  // === シールド回復アイテム描画 ===
  function drawShieldPickups() {
    if (!shieldPickups.length) return;
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (const pickup of shieldPickups) {
      const head = projectPoint(pickup.pos);
      if (!head) continue;
      const pulse = 0.6 + Math.sin(pickup.phase * 4) * 0.2;
      const radius = (pickup.radius + 3) * pulse;
      ctx.shadowColor = "rgba(0, 220, 255, 0.8)";
      ctx.shadowBlur = 24 * pulse;
      ctx.fillStyle = "rgba(0, 255, 230, 0.7)";
      ctx.beginPath();
      ctx.arc(head.x, head.y, radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      ctx.lineWidth = 2;
      ctx.strokeStyle = "rgba(255, 255, 255, 0.9)";
      ctx.beginPath();
      ctx.arc(head.x, head.y, radius * 0.7, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.restore();
  }

  function updateExplosions(dt) {
    for (let i = explosions.length - 1; i >= 0; i--) {
      const exp = explosions[i];
      exp.age += dt;
      if (exp.age >= exp.duration) {
        explosions.splice(i, 1);
      }
    }
  }

  // === シティオブジェクトとの衝突判定 ===
  function checkCityCollisions() {
    if (player.invuln > 0) return;
    for (const obj of cityObjects) {
      if (obj.type !== "building" || !obj.position || !obj.halfSize) continue;
      const minZ = obj.position.z - obj.halfSize.z - player.hitRadius;
      if (minZ > player.pos.z) continue;
      const maxZ = obj.position.z + obj.halfSize.z + player.hitRadius;
      if (maxZ < player.pos.z) continue;
      const minX = obj.position.x - obj.halfSize.x;
      const maxX = obj.position.x + obj.halfSize.x;
      const minY = obj.position.y - obj.halfSize.y;
      const maxY = obj.position.y + obj.halfSize.y;
      const clampedX = clamp(player.pos.x, minX, maxX);
      const clampedY = clamp(player.pos.y, minY, maxY);
      const clampedZ = clamp(player.pos.z, obj.position.z - obj.halfSize.z, obj.position.z + obj.halfSize.z);
      const dx = player.pos.x - clampedX;
      const dy = player.pos.y - clampedY;
      const dz = player.pos.z - clampedZ;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= player.hitRadius) {
        applyPlayerDamage(32, obj);
        camera.shake = Math.max(camera.shake, 1.1);
        break;
      }
    }
  }

  // === 宇宙アステロイドとの衝突判定 ===
  function checkSpaceCollisions() {
    if (player.invuln > 0) return;
    for (const obj of spaceScene.objects) {
      if (obj.type !== "asteroid" || !obj.center || !obj.radius) continue;
      const dx = player.pos.x - obj.center.x;
      const dy = player.pos.y - obj.center.y;
      const dz = player.pos.z - obj.center.z;
      const dist = Math.hypot(dx, dy, dz);
      if (dist <= obj.radius + player.hitRadius) {
        applyPlayerDamage(36, obj);
        camera.shake = Math.max(camera.shake, 1.2);
        break;
      }
    }
  }

  function resetPlayerVitals(fullRestore = true) {
    // 自機のシールドとHPを所定値にリセット
    player.hp = player.maxHp;
    player.shield = player.maxShield;
    player.invuln = 0;
    if (fullRestore) {
      missilesRemaining = MISSILE_STOCK_MAX;
      player.stocks = player.maxStocks;
    }
    player.visible = true; // 復活時には自機を再表示する
  }

  function respawnPlayer() {
    resetPlayerVitals(false);
    player.invuln = Math.max(player.invuln, 1.5);
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    shotCooldown = 0;
    missileCooldown = 0;
    missileRequest = false;
    enemyShots.length = 0;
    spawnExplosion(player.pos.x, player.pos.y, player.pos.z - 10, 1.8, 0.6);
  }

  // === ステージ0制御 ===
  function initStage0Scene() {
    gamePhase = "stage0";
    phaseTime = 0;
    stage1Clear = false;
    stageClear = false;
    gameOver = false;
    gameOverTime = 0;
    stage0State.doorProgress = 0;
    stage0State.launchProgress = 0;
    stage0State.thruster = 0;
    player.pos.x = 0;
    player.pos.y = stage0State.startY;
    player.pos.z = stage0State.startZ;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    resetPlayerVitals();
    missileRequest = false;
    shotCooldown = 0;
    missileCooldown = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    enemyShots.length = 0;
    explosions.length = 0;
    shieldPickups.length = 0;
    camera.pos.x = 4;
    camera.pos.y = player.pos.y + 6;
    camera.pos.z = player.pos.z + 56;
    camera.shake = 0;
    environment = "city";
    skyMix = 0;
  }

  function updateStage0(dt) {
    const t = phaseTime;
    const doorStart = 0.9;
    const doorEnd = 2.6;
    const launchStart = 2.8;
    const launchDuration = 3.8;
    const thrusterStart = 2.4;

    const doorRatio = (t - doorStart) / Math.max(doorEnd - doorStart, 0.1);
    stage0State.doorProgress = easeInOutCubic(clamp(doorRatio, 0, 1));
    stage0State.thruster = smoothstep((t - thrusterStart) / 0.9);
    const launchRatio = (t - launchStart) / Math.max(launchDuration, 0.1);
    const launchProgress = easeInOutCubic(clamp(launchRatio, 0, 1));
    stage0State.launchProgress = launchProgress;

    const lateralDrift = Math.sin(t * 0.6) * (1 - launchProgress) * 1.4;
    player.pos.x = lateralDrift;
    player.pos.z = stage0State.startZ + (stage0State.targetZ - stage0State.startZ) * launchProgress;
    const riseRatio = easeOutCubic((t - launchStart) / (launchDuration * 0.7));
    player.pos.y = stage0State.startY + (stage0State.targetY - stage0State.startY) * riseRatio;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = clamp(Math.sin(t * 1.3) * (1 - launchProgress) * 0.18, -0.3, 0.3);

    const camLag = 54 - launchProgress * 32;
    camera.pos.x = player.pos.x * 0.5 - Math.sin(t * 0.4) * (1 - launchProgress) * 3.2;
    camera.pos.y = player.pos.y + 6 + (1 - launchProgress) * 4.2 - stage0State.thruster * 1.6;
    camera.pos.z = player.pos.z + camLag;
    camera.shake = Math.max(camera.shake * Math.pow(0.25, dt), stage0State.thruster * 0.35);

    if (launchProgress >= 1 && t >= launchStart + launchDuration + 0.5) {
      enterStage1();
    }
  }

  function enterStage1() {
    if (gamePhase !== "stage0") return;
    gamePhase = "stage1";
    phaseTime = 0;
    player.pos.x = 0;
    player.pos.y = stage0State.targetY;
    player.pos.z = stage0State.targetZ;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    resetPlayerVitals();
    missileRequest = false;
    shotCooldown = 0;
    missileCooldown = 0;
    missilesRemaining = MISSILE_STOCK_MAX;
    initCityEnemies();
  }

  function drawExplosions() {
    if (!explosions.length) return;
    ctx.save();
    for (const exp of explosions) {
      const t = exp.age / exp.duration;
      const fade = Math.max(0, 1 - t);
      const center = { x: exp.pos.x, y: exp.pos.y, z: exp.pos.z };
      for (const shard of exp.shards) {
        const stretch = shard.len * (0.6 + t * 2.4);
        const tailStretch = shard.len * (0.2 + t * 0.6);
        const head = {
          x: center.x + shard.dir.x * stretch,
          y: center.y + shard.dir.y * stretch,
          z: center.z + shard.dir.z * stretch,
        };
        const tail = {
          x: center.x + shard.dir.x * tailStretch,
          y: center.y + shard.dir.y * tailStretch,
          z: center.z + shard.dir.z * tailStretch,
        };
        const pHead = projectPoint(head);
        const pTail = projectPoint(tail);
        if (!pHead || !pTail) continue;
        ctx.lineWidth = 1.0 + exp.scale * (0.8 + t * 1.2);
        ctx.strokeStyle = `rgba(255, 220, 120, ${0.08 + fade * 0.42})`;
        ctx.shadowColor = `rgba(255, 200, 120, ${0.2 * fade})`;
        ctx.shadowBlur = 18 * fade;
        ctx.beginPath();
        ctx.moveTo(pTail.x, pTail.y);
        ctx.lineTo(pHead.x, pHead.y);
        ctx.stroke();

        ctx.lineWidth = 0.8 + exp.scale * (0.6 + t * 0.9);
        ctx.strokeStyle = `rgba(0, 200, 255, ${0.05 + fade * 0.28})`;
        ctx.shadowColor = `rgba(0, 150, 255, ${0.18 * fade})`;
        ctx.shadowBlur = 12 * fade;
        ctx.beginPath();
        ctx.moveTo(pTail.x, pTail.y);
        ctx.lineTo(pHead.x, pHead.y);
        ctx.stroke();
      }

      for (const ring of exp.rings || []) {
        const segs = 28;
        const radius = ring.baseRadius * (0.25 + t * 1.5);
        const cosTilt = Math.cos(ring.tilt);
        const sinTilt = Math.sin(ring.tilt);
        let prevPoint = null;
        for (let s = 0; s <= segs; s++) {
          const phi = (s / segs) * Math.PI * 2;
          const lx = Math.cos(phi) * radius;
          const lz = Math.sin(phi) * radius;
          const ly = -lz * sinTilt;
          const wz = lz * cosTilt;
          const worldPoint = {
            x: center.x + lx,
            y: center.y + ring.height + ly,
            z: center.z + wz,
          };
          const proj = projectPoint(worldPoint);
          if (!proj) {
            prevPoint = null;
            continue;
          }
          if (prevPoint) {
            const energy = fade * (1 - Math.abs(s / segs - 0.5) * 0.2);
            ctx.lineWidth = 1.2 + exp.scale * (0.5 + 0.6 * fade);
            ctx.strokeStyle = `rgba(0, 200, 255, ${0.04 + energy * 0.22})`;
            ctx.shadowColor = `rgba(0, 140, 255, ${0.2 * energy})`;
            ctx.shadowBlur = 14 * energy;
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();

            ctx.lineWidth = 0.8 + exp.scale * (0.3 + 0.4 * fade);
            ctx.strokeStyle = `rgba(255, 230, 160, ${0.05 + energy * 0.18})`;
            ctx.shadowColor = `rgba(255, 210, 140, ${0.16 * energy})`;
            ctx.shadowBlur = 10 * energy;
            ctx.beginPath();
            ctx.moveTo(prevPoint.x, prevPoint.y);
            ctx.lineTo(proj.x, proj.y);
            ctx.stroke();
          }
          prevPoint = proj;
        }
      }

      const core = projectPoint(center);
      if (core) {
        const coreAlpha = 0.12 + fade * 0.4;
        ctx.lineWidth = 0;
        ctx.fillStyle = `rgba(255, 255, 255, ${coreAlpha})`;
        ctx.shadowColor = `rgba(0, 200, 255, ${0.4 * fade})`;
        ctx.shadowBlur = 32 * fade;
        ctx.beginPath();
        ctx.arc(core.x, core.y, 12 * exp.scale * fade, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.restore();
  }

  function bossLocalToWorld(x, y, z) {
    const yaw = boss.turretYaw || 0;
    const cosA = Math.cos(yaw);
    const sinA = Math.sin(yaw);
    const rx = x * cosA + z * sinA;
    const rz = -x * sinA + z * cosA;
    return {
      x: boss.pos.x + rx,
      y: boss.pos.y + y,
      z: boss.pos.z + rz,
    };
  }

  function spawnBossShell() {
    if (!boss.active || boss.destroyed) return;
    const muzzle = bossLocalToWorld(0, 12, -84);
    const targetX = player.pos.x;
    const targetY = player.pos.y;
    const targetZ = player.pos.z;
    const dx = targetX - muzzle.x;
    const dy = targetY - muzzle.y;
    const dz = targetZ - muzzle.z;
    const dist = Math.hypot(dx, dy, dz);
    if (dist < 1e-3) return;
    const speed = 340;
    // ボスタンク砲もレーザー化して迫力を追加
    enemyShots.push({
      pos: muzzle,
      vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
      ttl: 2.6,
      lifeMax: 2.6,
      beam: true,
      beamLength: 0.34,
      width: 4.2,
      color: "rgba(255, 120, 160, 0.92)",
      glowStart: "rgba(255, 120, 200, 0.6)",
      glowEnd: "rgba(255, 70, 140, 0.05)",
      coreColor: "rgba(255, 255, 255, 0.92)",
      shadowColor: "rgba(255, 100, 190, 0.85)",
      spawnTime: performance.now(),
      pulseSpeed: 5.4,
      pulseRange: 0.22,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: 32,
      hitRadius: 10,
    });
  }

  // === 戦艦波動砲発射 ===
  function spawnWaveCannon() {
    if (!boss.active || boss.destroyed) return;
    const muzzle = bossLocalToWorld(0, 18, -210);
    const target = {
      x: player.pos.x,
      y: player.pos.y,
      z: player.pos.z,
    };
    const dx = target.x - muzzle.x;
    const dy = target.y - muzzle.y;
    const dz = target.z - muzzle.z;
    const dist = Math.hypot(dx, dy, dz) || 1;
    const speed = 520;
    // 波動砲は長尺ビームとして描画
    enemyShots.push({
      pos: { ...muzzle },
      vel: { x: (dx / dist) * speed, y: (dy / dist) * speed, z: (dz / dist) * speed },
      ttl: 1.6,
      lifeMax: 1.6,
      beam: true,
      beamLength: 1.6,
      width: 22,
      color: "rgba(0, 210, 255, 0.96)",
      glowStart: "rgba(0, 220, 255, 0.72)",
      glowEnd: "rgba(0, 140, 255, 0.12)",
      coreColor: "rgba(255, 255, 255, 0.96)",
      shadowColor: "rgba(0, 180, 255, 0.9)",
      spawnTime: performance.now(),
      pulseSpeed: 4.2,
      pulseRange: 0.25,
      pulseOffset: Math.random() * Math.PI * 2,
      damage: 60,
      hitRadius: 18,
    });
    audioSystem.playWaveCannon(); // 波動砲専用の効果音を再生
    boss.waveCharge = 1;
    boss.shake = 1.6;
  }

  function updateBoss(dt) {
    if (boss.variant === "battleship") {
      updateBattleshipBoss(dt);
      return;
    }
    if (boss.destroyed) {
      boss.shake = Math.max(0, boss.shake - dt * 1.8);
      return;
    }
    if (!boss.active && player.pos.z <= boss.spawnTriggerZ) {
      boss.active = true;
    }
    if (!boss.active) return;
    boss.shake = Math.max(0, boss.shake - dt * 1.8);
    const dx = player.pos.x - boss.pos.x;
    const dz = player.pos.z - boss.pos.z;
    const targetYaw = Math.atan2(dx, -(dz || 1e-3));
    boss.turretYaw += (targetYaw - boss.turretYaw) * Math.min(1, dt * 2.6);
    boss.fireCooldown -= dt;
    if (boss.fireCooldown <= 0 && !stageClear) {
      spawnBossShell();
      boss.fireCooldown = boss.fireInterval + Math.random() * 0.4;
    }
  }

  // === 戦艦ボス挙動 ===
  function updateBattleshipBoss(dt) {
    if (boss.destroyed) {
      boss.shake = Math.max(0, boss.shake - dt * 1.2);
      boss.waveCharge = Math.max(0, boss.waveCharge - dt * 2.2);
      return;
    }
    if (!boss.active && player.pos.z <= boss.spawnTriggerZ) {
      boss.active = true;
    }
    if (!boss.active) return;
    boss.shake = Math.max(0, boss.shake - dt * 0.8);
    const dx = player.pos.x - boss.pos.x;
    const dz = player.pos.z - boss.pos.z;
    const targetYaw = Math.atan2(dx, -(dz || 1e-3));
    boss.turretYaw += (targetYaw - boss.turretYaw) * Math.min(1, dt * 1.6);
    boss.fireCooldown -= dt;
    boss.waveCharge = Math.max(0, boss.waveCharge - dt * 1.4);
    const targetY = Math.max(150, Math.min(220, player.pos.y - 8));
    boss.pos.y += (targetY - boss.pos.y) * Math.min(1, dt * 0.6);
    const targetZ = player.pos.z - 520;
    boss.pos.z += (targetZ - boss.pos.z) * Math.min(1, dt * 0.4);
    if (boss.fireCooldown <= 0 && !stageClear) {
      spawnWaveCannon();
      boss.fireCooldown = boss.fireInterval + Math.random() * 1.6;
    }
  }

  // === 都市レーン構築 ===
  function initCity() {
    cityObjects.length = 0;
    const laneWidth = 36;
    const blockDepth = 140; // ブロック間隔を広げて進行距離を延伸
    const laneCount = 16; // ビル密集地帯を終えた先にボスエリアを配置
    for (let i = 0; i < laneCount; i++) {
      const z = -i * blockDepth - 80;
      // 左右にビル群を配置
      for (const side of [-1, 1]) {
        const baseX = side * (laneWidth * 0.7);
        const towerCount = 3;
        for (let t = 0; t < towerCount; t++) {
          const offsetX = baseX + side * (Math.random() * 12 + t * 6);
          const baseY = Math.random() * 4;
          const height = 40 + Math.random() * 80;
          const width = 10 + Math.random() * 14;
          const depth = 10 + Math.random() * 14;
          const centerZ = z - t * 12;
          cityObjects.push({
            type: "building",
            zOrigin: z,
            position: { x: offsetX, y: height * 0.5 + baseY, z: centerZ },
            halfSize: { x: width * 0.5, y: height * 0.5, z: depth * 0.5 },
            edges: createBoxEdges(offsetX, height * 0.5 + baseY, centerZ, width, height, depth),
          });
        }
      }
    }
    // ゲートを中央レーンに配置
    const gateZ = -960; // ゲートを遠方へ移動してフライト時間を確保
    cityObjects.push({
      type: "gate",
      zOrigin: gateZ,
      edges: edgesToFloat32(createGateEdges(0, 24, gateZ, 40, 32, 8, 4)),
    });
    // 地面グリッド
    cityObjects.push({
      type: "ground",
      zOrigin: 0,
      edges: edgesToFloat32(createGroundGrid(20, -3800, 20, 90)),
    });
  }

  // === シールドキャリア抽選 ===
  function maybeAssignShieldCarrier(enemy, chance = 0.18) {
    if (!enemy || enemy.dropShield) return;
    if (Math.random() >= chance) return;
    enemy.dropShield = true;
    enemy.shieldReward = enemy.shieldReward || 40;
    if (typeof enemy.maxHp === "number") {
      enemy.maxHp = Math.round(enemy.maxHp * 1.2);
      enemy.hp = enemy.maxHp;
    } else if (typeof enemy.hp === "number") {
      enemy.hp = Math.round(enemy.hp * 1.2);
    }
  }

  function initCityEnemies() {
    enemyObjects.length = 0;
    // 空中戦闘機
    const airSpawns = [-360, -520, -720];
    airSpawns.forEach((z, idx) => {
      const side = idx % 2 === 0 ? 1 : -1;
      const enemy = {
        type: "air",
        shape: enemyFighterShape,
        base: { x: side * 18, y: 20, z },
        pathCenterX: side * 18,
        amplitudeX: 16,
        amplitudeY: 4,
        frequency: 0.9 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        fireInterval: 1.3 + Math.random() * 0.6,
        fireCooldown: Math.random() * 1.0,
        hp: 80,
        maxHp: 80,
        hitRadius: 11,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.16);
      enemyObjects.push(enemy);
    });
    // 地上ロボット
    const groundSpawns = [-430, -660];
    groundSpawns.forEach((z, idx) => {
      const side = idx % 2 === 0 ? -1 : 1;
      const enemy = {
        type: "ground",
        shape: enemyRobotShape,
        base: { x: side * 28, y: 2.2, z },
        pathCenterX: side * 28,
        amplitudeX: 10,
        frequency: 1.4 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        fireInterval: 1.7 + Math.random() * 0.5,
        fireCooldown: Math.random() * 1.2,
        hp: 120,
        maxHp: 120,
        hitRadius: 12,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.14);
      enemyObjects.push(enemy);
    });
    // 画面手前に迫る航空機編隊
    const formationOffsets = [
      { x: 0, y: 0, z: 0 },
      { x: -9, y: -1.5, z: -18 },
      { x: 9, y: -1.5, z: -18 },
      { x: -14, y: -2.5, z: -34 },
      { x: 14, y: -2.5, z: -34 },
    ];
    const resetDistance = 1250;
    formationOffsets.forEach((offset, idx) => {
      const enemy = {
        type: "incoming",
        shape: enemyFighterShapeIncoming,
        base: { x: offset.x, y: 22 + offset.y, z: player.pos.z - resetDistance + offset.z },
        pathCenterX: offset.x,
        amplitudeX: 4,
        amplitudeY: 2.8,
        frequency: 1.05 + idx * 0.07,
        phase: idx * 0.45,
        speed: 210,
        resetDistance,
        formationOffset: offset,
        originalX: offset.x,
        fireInterval: 0.9 + Math.random() * 0.4,
        fireCooldown: Math.random() * 0.8,
        hp: 90,
        maxHp: 90,
        hitRadius: 10,
        hitFlash: 0,
      };
      maybeAssignShieldCarrier(enemy, 0.12);
      enemyObjects.push(enemy);
    });
    // 後方から追尾するエース機
    const pursuer = {
      type: "pursuer",
      shape: enemyFighterShape,
      base: { x: player.pos.x, y: player.pos.y + 8, z: player.pos.z + 28 },
      amplitudeX: 2.5,
      amplitudeY: 1.8,
      frequency: 1.4,
      phase: Math.random() * Math.PI * 2,
      trailDistance: 24,
      chaseLerp: 4.0,
      chaseLerpZ: 2.6,
      swayFreq: 1.7,
      swayAmp: 6,
      fireInterval: 0.75 + Math.random() * 0.35,
      fireCooldown: 1.0,
      hp: 150,
      maxHp: 150,
      hitRadius: 12,
      hitFlash: 0,
    };
    maybeAssignShieldCarrier(pursuer, 0.2);
    enemyObjects.push(pursuer);
  }

  function initSpaceScene() {
    spaceScene.objects.length = 0;
    spaceScene.rings.length = 0;
    spaceScene.walkers.length = 0;
    spaceScene.corridors.length = 0;
    spaceScene.guideBeacons.length = 0;
    spaceScene.stars = generateStarField(220, 3600, player.pos.z - 2000);
    const layers = [
      { count: 8, radius: 42, height: 86, depth: -2600 },
      { count: 10, radius: 64, height: 120, depth: -3000 },
      { count: 12, radius: 90, height: 160, depth: -3400 },
    ];
    for (const layer of layers) {
      for (let i = 0; i < layer.count; i++) {
        const angle = (i / layer.count) * Math.PI * 2 + Math.random() * 0.2;
        const r = layer.radius + Math.random() * 12 - 6;
        const x = Math.cos(angle) * r;
        const z = layer.depth - Math.sin(angle) * r * 1.6;
        const y = layer.height + Math.sin(angle * 2) * 12;
        const scale = 1.2 + Math.random() * 0.8;
        const cluster = createAsteroidCluster(x, y, z, scale);
        spaceScene.objects.push({
          type: "asteroid",
          center: { x, y, z },
          radius: 9 * scale,
          edges: edgesToFloat32(cluster),
        });
      }
    }
    const corridorStart = -2600;
    const corridorLength = 2200;
    const corridorEdges = edgesToFloat32(createSpaceCorridor(0, 148, corridorStart, corridorLength, 20, 26));
    spaceScene.corridors.push({ type: "corridor", edges: corridorEdges });
    for (let i = 0; i < 6; i++) {
      const offset = (i / 5) * corridorLength;
      const baseZ = corridorStart - offset - 120;
      const offsetX = (Math.random() * 2 - 1) * 52;
      const offsetY = 150 + Math.random() * 50;
      const scale = 1.8 + Math.random() * 1.6;
      const clusterA = createAsteroidCluster(offsetX, offsetY, baseZ, scale);
      spaceScene.objects.push({
        type: "asteroid",
        center: { x: offsetX, y: offsetY, z: baseZ },
        radius: 9 * scale,
        edges: edgesToFloat32(clusterA),
      });
      const offsetX2 = offsetX * -0.6;
      const offsetY2 = offsetY - 24;
      const baseZ2 = baseZ - 60;
      const scale2 = scale * 0.8;
      const clusterB = createAsteroidCluster(offsetX2, offsetY2, baseZ2, scale2);
      spaceScene.objects.push({
        type: "asteroid",
        center: { x: offsetX2, y: offsetY2, z: baseZ2 },
        radius: 9 * scale2,
        edges: edgesToFloat32(clusterB),
      });
    }
    const beaconCount = 14;
    for (let i = 0; i <= beaconCount; i++) {
      const t = i / beaconCount;
      const z = corridorStart - corridorLength * t;
      const sway = Math.sin(t * Math.PI * 1.5) * 6;
      spaceScene.guideBeacons.push({
        x: sway * 0.4,
        y: 150 + Math.sin(t * Math.PI) * 18,
        z,
        phase: Math.random() * Math.PI * 2,
      });
    }
    const ringEdges = edgesToFloat32(createAsteroidRingEdges(0, 140, -3000, 52, 12, 32));
    spaceScene.rings.push({ type: "ring", edges: ringEdges });
  }

  function initSpaceEnemies() {
    enemyObjects.length = 0;
    const ambushPositions = [-2800, -3100, -3320, -3600];
    ambushPositions.forEach((z, idx) => {
      const side = idx % 2 === 0 ? -1 : 1;
      const base = { x: side * 26, y: 160 + Math.random() * 18, z };
      const enemy = {
        type: "ambush",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        amplitudeX: 8,
        amplitudeY: 5,
        frequency: 0.8 + Math.random() * 0.5,
        phase: Math.random() * Math.PI * 2,
        hp: 120,
        maxHp: 120,
        hitRadius: 12,
        fireInterval: 1.4 + Math.random() * 0.5,
        fireCooldown: 0.6 + Math.random() * 0.6,
      };
      maybeAssignShieldCarrier(enemy, 0.18);
      enemyObjects.push(enemy);
    });
    const walkerAnchors = [
      { x: -34, y: 168, z: -2950 },
      { x: 28, y: 180, z: -3220 },
      { x: -12, y: 192, z: -3480 },
    ];
    walkerAnchors.forEach((anchor, idx) => {
      const radius = 9 + Math.random() * 4;
      spaceScene.walkers.push({ ...anchor, radius });
      spaceScene.objects.push({
        type: "platform",
        edges: edgesToFloat32(createBoxEdges(anchor.x, anchor.y - 2.4, anchor.z, radius * 2.6, 2.6, radius * 2.6)),
      });
      const phase = Math.random() * Math.PI * 2;
      const startX = anchor.x + Math.cos(phase) * radius;
      const startZ = anchor.z + Math.sin(phase) * radius;
      const walker = {
        type: "walker",
        shape: enemyRobotShape,
        orbitCenter: { ...anchor },
        base: { x: startX, y: anchor.y, z: startZ },
        orbitSpeed: 0.6 + idx * 0.12,
        walkPhase: phase,
        orbitRadius: radius,
        hp: 150,
        maxHp: 150,
        hitRadius: 14,
        fireInterval: 1.8 + Math.random() * 0.3,
        fireCooldown: Math.random() * 1.4,
      };
      maybeAssignShieldCarrier(walker, 0.12);
      enemyObjects.push(walker);
    });
    const interceptors = [-2880, -3160, -3420, -3740];
    interceptors.forEach((z, idx) => {
      const offsetX = (idx % 2 === 0 ? -1 : 1) * (14 + idx * 2);
      const base = { x: offsetX, y: 184, z };
      const interceptor = {
        type: "spaceAir",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        amplitudeX: 12,
        amplitudeY: 8,
        frequency: 1.3 + idx * 0.18,
        phase: Math.random() * Math.PI * 2,
        speed: 240,
        hp: 110,
        maxHp: 110,
        hitRadius: 11,
        fireInterval: 1.0 + Math.random() * 0.4,
        fireCooldown: Math.random() * 0.8,
      };
      maybeAssignShieldCarrier(interceptor, 0.2);
      enemyObjects.push(interceptor);
    });
    const corridorGuards = 12;
    for (let i = 0; i < corridorGuards; i++) {
      const lane = (i % 3 - 1) * 18 + (Math.random() * 6 - 3);
      const baseZ = -2700 - i * 150;
      const base = { x: lane, y: 172 + Math.random() * 14, z: baseZ };
      const guard = {
        type: "corridorGuard",
        shape: enemyFighterShape,
        base,
        home: { ...base },
        laneX: lane,
        bobAmp: 10 + Math.random() * 6,
        speed: 220 + Math.random() * 40,
        frequency: 1.1 + Math.random() * 0.4,
        phase: Math.random() * Math.PI * 2,
        hp: 140,
        maxHp: 140,
        hitRadius: 13,
        fireInterval: 0.9 + Math.random() * 0.4,
        fireCooldown: 0.4 + Math.random() * 0.6,
      };
      maybeAssignShieldCarrier(guard, 0.15);
      enemyObjects.push(guard);
    }
  }

  initStage0Scene();
  initCity();

  // === ウインドウリサイズ対応 ===
  function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = Math.round(window.innerWidth * dpr);
    canvas.height = Math.round(window.innerHeight * dpr);
    canvas.style.width = "100vw";
    canvas.style.height = "100vh";
    ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  // === ビルの再配置（エンドレス化） ===
  function recycleCityObjects() {
    for (const obj of cityObjects) {
      if (obj.type === "ground" || obj.type === "gate") continue;
      const worldZ = obj.position ? obj.position.z : obj.zOrigin;
      if (worldZ > player.pos.z + 120) {
        const move = 2400;
        if (obj.position) obj.position.z -= move;
        if (obj.edges) {
          for (const edge of obj.edges) {
            edge[0].z -= move;
            edge[1].z -= move;
          }
        }
      }
    }
  }

  function updateEnemies(dt) {
    if (stageClear) return;
    for (let i = enemyObjects.length - 1; i >= 0; i--) {
      const enemy = enemyObjects[i];
      if (!enemy) continue;
      if (enemy.hitFlash) {
        enemy.hitFlash = Math.max(0, enemy.hitFlash - dt * 2.4);
      }
      if (enemy.type === "air" || enemy.type === "ground") {
        if (enemy.base.z > player.pos.z + 140) {
          enemy.base.z -= 2400;
          enemy.pathCenterX = (Math.random() * 2 - 1) * 26;
          enemy.phase = Math.random() * Math.PI * 2;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "incoming") {
        enemy.base.z += (enemy.speed || 200) * dt;
        if (enemy.base.z > player.pos.z + 100) {
          const reset = enemy.resetDistance || 1200;
          const offsetZ = enemy.formationOffset ? enemy.formationOffset.z : 0;
          enemy.base.z = player.pos.z - reset + offsetZ;
          enemy.pathCenterX = (enemy.originalX || 0) + (Math.random() * 2 - 1) * 4;
          enemy.phase = Math.random() * Math.PI * 2;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "pursuer") {
        const lerp = Math.min(1, dt * (enemy.chaseLerp || 3.0));
        const targetX = clamp(player.pos.x + Math.sin(simTime * (enemy.swayFreq || 1.6)) * (enemy.swayAmp || 5), -30, 30);
        const targetY = clamp(player.pos.y + 4, 6, 26);
        enemy.base.x += (targetX - enemy.base.x) * lerp;
        enemy.base.y += (targetY - enemy.base.y) * lerp;
        const lerpZ = Math.min(1, dt * (enemy.chaseLerpZ || 2.0));
        const targetZ = player.pos.z + (enemy.trailDistance || 24);
        enemy.base.z += (targetZ - enemy.base.z) * lerpZ;
      } else if (enemy.type === "ambush") {
        const home = enemy.home || enemy.base;
        const freq = enemy.frequency || 1.0;
        const wave = Math.sin(simTime * freq + (enemy.phase || 0));
        const sway = Math.cos(simTime * freq * 0.6 + (enemy.phase || 0));
        enemy.base.x = clamp((home.x || 0) + wave * (enemy.amplitudeX || 0), -80, 80);
        enemy.base.y = (home.y || 140) + sway * (enemy.amplitudeY || 0);
        if (player.pos.z - enemy.base.z < 220) {
          enemy.base.z -= dt * 110;
        }
      } else if (enemy.type === "spaceAir") {
        const home = enemy.home || enemy.base;
        const freq = enemy.frequency || 1.0;
        const wave = Math.sin(simTime * freq + (enemy.phase || 0));
        const sway = Math.cos(simTime * freq * 0.8 + (enemy.phase || 0));
        enemy.base.x = clamp((home.x || 0) + wave * (enemy.amplitudeX || 0), -90, 90);
        enemy.base.y = (home.y || 150) + sway * (enemy.amplitudeY || 0);
        enemy.base.z += (enemy.speed || 240) * dt;
        if (enemy.base.z > player.pos.z + 120) {
          enemy.base.z = player.pos.z - 900 - Math.random() * 260;
          if (enemy.home) enemy.home.z = enemy.base.z;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "corridorGuard") {
        const lane = enemy.laneX || 0;
        const bob = enemy.bobAmp || 10;
        const freq = enemy.frequency || 1.0;
        enemy.phase = (enemy.phase || 0) + dt * freq;
        const guide = spaceScene.guidePhase || 0;
        enemy.base.x = clamp(lane + Math.sin(enemy.phase) * 4.5, -72, 72);
        enemy.base.y = ((enemy.home && enemy.home.y) || 172) + Math.sin(guide + enemy.phase) * bob;
        enemy.base.z += (enemy.speed || 240) * dt;
        if (enemy.base.z > player.pos.z + 140) {
          enemy.base.z = player.pos.z - 880 - Math.random() * 220;
          if (enemy.home) enemy.home.z = enemy.base.z;
          if (typeof enemy.maxHp === "number") enemy.hp = enemy.maxHp;
        }
      } else if (enemy.type === "walker") {
        enemy.walkPhase = (enemy.walkPhase || 0) + dt * (enemy.orbitSpeed || 0.8);
        const radius = enemy.orbitRadius || 10;
        const center = enemy.orbitCenter || enemy.base;
        enemy.base.x = center.x + Math.cos(enemy.walkPhase) * radius;
        enemy.base.z = center.z + Math.sin(enemy.walkPhase) * radius;
        enemy.base.y = center.y + Math.sin(enemy.walkPhase * 2) * 1.4;
      }
      if (enemy.fireInterval) {
        enemy.fireCooldown = (enemy.fireCooldown ?? enemy.fireInterval) - dt;
        if (enemy.fireCooldown <= 0) {
          const pose = getEnemyPose(enemy);
          if (pose) {
            const dz = player.pos.z - pose.z;
            let canFire = false;
            if (enemy.type === "ground") {
              canFire = dz > 10 && dz < 320;
            } else if (enemy.type === "pursuer") {
              canFire = dz > 12 && dz < 140;
            } else {
              canFire = dz > 20 && dz < 720;
            }
            if (canFire) {
              spawnEnemyShot(enemy);
              enemy.fireCooldown += enemy.fireInterval;
            } else {
              enemy.fireCooldown += Math.max(0.4, enemy.fireInterval * 0.5);
            }
          } else {
            enemy.fireCooldown = enemy.fireInterval;
          }
        }
      }
    }
  }

  // === 自機のワイヤーフレーム ===
  function getPlayerEdges() {
    const wingSpan = 18;
    const noseZ = player.pos.z - 16;
    const tailZ = player.pos.z + 4;
    const centerY = player.pos.y;
    const rawEdges = [
      // 主翼ライン
      [
        { x: player.pos.x - wingSpan * 0.5, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x + wingSpan * 0.5, y: centerY, z: player.pos.z - 4 },
      ],
      // 機首
      [
        { x: player.pos.x - 2, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY - 2, z: noseZ },
      ],
      [
        { x: player.pos.x + 2, y: centerY, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY - 2, z: noseZ },
      ],
      // 胴体上部
      [
        { x: player.pos.x, y: centerY - 2, z: noseZ },
        { x: player.pos.x, y: centerY + 2, z: tailZ },
      ],
      // 垂直尾翼
      [
        { x: player.pos.x, y: centerY + 2, z: tailZ },
        { x: player.pos.x, y: centerY + 6, z: tailZ + 4 },
      ],
      [
        { x: player.pos.x, y: centerY + 2, z: player.pos.z - 4 },
        { x: player.pos.x, y: centerY + 6, z: tailZ },
      ],
    ];
    const cosR = Math.cos(player.roll);
    const sinR = Math.sin(player.roll);
    const rotated = rawEdges.map(([a, b]) => {
      const arx = (a.x - player.pos.x) * cosR - (a.y - centerY) * sinR + player.pos.x;
      const ary = (a.x - player.pos.x) * sinR + (a.y - centerY) * cosR + centerY;
      const brx = (b.x - player.pos.x) * cosR - (b.y - centerY) * sinR + player.pos.x;
      const bry = (b.x - player.pos.x) * sinR + (b.y - centerY) * cosR + centerY;
      return [
        { x: arx, y: ary, z: a.z },
        { x: brx, y: bry, z: b.z },
      ];
    });
    return rotated;
  }

  // === メインループ ===
  let prevTime = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - prevTime) / 1000);
    prevTime = now;

    update(dt);
    render();

    requestAnimationFrame(loop);
  }

  // === 自機とカメラの更新 ===
  function update(dt) {
    simTime += dt;
    player.invuln = Math.max(0, player.invuln - dt);
    if (gamePhase === "stage0") {
      phaseTime += dt;
      updateStage0(dt);
      return;
    }
    if (gamePhase === "gameOver") {
      phaseTime += dt;
      updateGameOver(dt);
      return;
    }
    if (gamePhase === "cityExit") {
      phaseTime += dt;
      updateCityExit(dt);
      return;
    }
    if (gamePhase === "stage2") {
      phaseTime += dt;
      updateStage2(dt);
      return;
    }
    if (gamePhase === "finalClear") {
      phaseTime += dt;
      updateFinalClear(dt);
      return;
    }

    phaseTime += dt;
    updateStage1(dt);
  }

  function updateStage1(dt) {
    const lateralSpeed = 160;   // スペースハリアー風の俊敏な横移動速度
    const verticalSpeed = 150;  // 同じく縦方向の移動速度
    const boundsX = 32;
    const boundsY = 38; // スペースハリアー風に縦方向の可動域を広げて画面上部へも追い込めるように

    let inputX = 0;
    let inputY = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) inputX -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) inputX += 1;
    if (keys.has("ArrowUp") || keys.has("KeyW")) inputY -= 1;
    if (keys.has("ArrowDown") || keys.has("KeyS")) inputY += 1;

    // スペースハリアーのようにキー入力を即座に反映してクイックに位置決定
    const deltaX = inputX * lateralSpeed * dt;
    const deltaY = inputY * verticalSpeed * dt;
    player.pos.x = clamp(player.pos.x + deltaX, -boundsX, boundsX);
    player.pos.y = clamp(player.pos.y + deltaY, 2, boundsY);
    player.vel.x = deltaX / Math.max(dt, 1e-4);
    player.vel.y = deltaY / Math.max(dt, 1e-4);
    let forwardSpeed = player.speedForward;
    if (boss.active && !boss.destroyed) {
      forwardSpeed = 0;
    }
    player.pos.z -= forwardSpeed * dt;
    if (boss.active && !boss.destroyed) {
      const distance = player.pos.z - boss.pos.z;
      const clamped = clamp(distance, bossDistanceConstraint.min, bossDistanceConstraint.max);
      const targetZ = boss.pos.z + clamped;
      const followRate = Math.min(1, dt * 3.8);
      player.pos.z += (targetZ - player.pos.z) * followRate;
    }

    player.roll = 0; // ロールを廃してスペースハリアー特有の平行移動に統一

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 9);
    camera.pos.y += (player.pos.y + 6 - camera.pos.y) * Math.min(1, dt * 6);
    camera.pos.z = player.pos.z + 40;

    environment = "city";
    skyMix = Math.max(0, skyMix - dt * 0.25);

    checkCityCollisions();
    updateShieldPickups(dt);

    recycleCityObjects();
    updateEnemies(dt);
    updateBoss(dt);
    updatePlayerWeapons(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === シティ撃破後の上昇シーケンス ===
  function updateCityExit(dt) {
    environment = cityExitState.progress < 0.75 ? "city" : "space";
    const accelDecay = Math.pow(0.22, dt * 60);
    player.vel.x *= accelDecay;
    player.vel.y *= accelDecay;
    const prevProg = cityExitState.progress;
    cityExitState.progress = Math.min(1, cityExitState.progress + dt / cityExitState.duration);
    const t = cityExitState.progress;
    const speedBoost = 0.9 + t * 0.35;
    player.pos.z -= player.speedForward * speedBoost * dt;
    if (!cityExitState.passed && player.pos.z <= boss.pos.z - 160) {
      cityExitState.passed = true;
    }
    const climbStart = 0.35;
    const climb = smoothstep((t - climbStart) / Math.max(0.0001, 1 - climbStart));
    const targetY = stage0State.targetY + 220 + climb * 340;
    player.pos.y += (targetY - player.pos.y) * Math.min(1, dt * 1.6);
    player.pos.x *= Math.pow(0.6, dt * 60);
    player.roll *= Math.pow(0.18, dt * 60);

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 1.4);
    camera.pos.y = player.pos.y + 16 - climb * 6;
    camera.pos.z = player.pos.z + 36 - climb * 32;

    skyMix = Math.min(1, skyMix + dt * 0.5 + t * 0.12);

    spaceScene.guidePhase = (spaceScene.guidePhase + dt * 1.8) % (Math.PI * 2);
    animateStars(dt);
    updateShieldPickups(dt);
    updateProjectiles(dt);
    updateExplosions(dt);

    if (prevProg < 1 && cityExitState.progress >= 1) {
      startSpaceStage();
    }
  }

  // === 宇宙ステージ初期化 ===
  function startSpaceStage() {
    cityExitState.progress = 0;
    cityExitState.passed = false;
    environment = "space";
    skyMix = 1;
    player.vel.x = 0;
    player.vel.y = 0;
    player.roll = 0;
    player.pos.y = Math.max(player.pos.y, 240);
    player.pos.z = -1800;
    camera.pos.x = player.pos.x;
    camera.pos.y = player.pos.y + 18;
    camera.pos.z = player.pos.z + 60;
    missilesRemaining = MISSILE_STOCK_MAX;
    enemyShots.length = 0;
    playerShots.length = 0;
    playerMissiles.length = 0;
    explosions.length = 0;
    shieldPickups.length = 0;
    resetPlayerVitals(false);
    player.shield = player.maxShield; // 宇宙突入時にシールドを再充填
    player.invuln = 1.2;
    spaceScene.waveTimer = 0;
    initSpaceScene();
    initSpaceEnemies();
    spaceScene.guidePhase = 0;
    setupSpaceBattleship();
    gamePhase = "stage2";
    phaseTime = 0;
  }

  // === 宇宙ステージの更新 ===
  function updateStage2(dt) {
    environment = "space";
    skyMix = Math.min(1, skyMix + dt * 0.35);
    const lateralSpeed = 180;
    const verticalSpeed = 190;
    const boundsX = 48;
    const boundsY = 210;
    const minAltitude = 32 + Math.min(1, skyMix) * 18; // 上空への逃げ場を確保しつつ下限は低めに維持

    let inputX = 0;
    let inputY = 0;
    if (keys.has("ArrowLeft") || keys.has("KeyA")) inputX -= 1;
    if (keys.has("ArrowRight") || keys.has("KeyD")) inputX += 1;
    if (keys.has("ArrowUp") || keys.has("KeyW")) inputY -= 1;
    if (keys.has("ArrowDown") || keys.has("KeyS")) inputY += 1;

    // 宇宙空間でもハリアー風の即応移動を適用
    const deltaX = inputX * lateralSpeed * dt;
    const deltaY = inputY * verticalSpeed * dt;
    player.pos.x = clamp(player.pos.x + deltaX, -boundsX, boundsX);
    player.pos.y = clamp(player.pos.y + deltaY, minAltitude, boundsY);
    player.vel.x = deltaX / Math.max(dt, 1e-4);
    player.vel.y = deltaY / Math.max(dt, 1e-4);

    let forwardSpeed = player.speedForward * 1.25;
    if (boss.active && !boss.destroyed && boss.variant === "battleship") {
      forwardSpeed = player.speedForward * 0.7;
    }
    player.pos.z -= forwardSpeed * dt;
    if (boss.active && !boss.destroyed && boss.variant === "battleship") {
      const distance = player.pos.z - boss.pos.z;
      const clamped = clamp(distance, battleshipDistanceConstraint.min, battleshipDistanceConstraint.max);
      const targetZ = boss.pos.z + clamped;
      player.pos.z += (targetZ - player.pos.z) * Math.min(1, dt * 2.8);
    }

    player.roll = 0;

    checkSpaceCollisions();
    updateShieldPickups(dt);

    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 8);
    camera.pos.y += (player.pos.y + 10 - camera.pos.y) * Math.min(1, dt * 5);
    camera.pos.z = player.pos.z + 52;

    spaceScene.waveTimer += dt;
    spaceScene.guidePhase = (spaceScene.guidePhase + dt * 2.2) % (Math.PI * 2);
    animateStars(dt);
    updateEnemies(dt);
    updateBoss(dt);
    updatePlayerWeapons(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === 最終クリア演出 ===
  function updateFinalClear(dt) {
    environment = "space";
    skyMix = 1;
    player.vel.x *= Math.pow(0.2, dt * 60);
    player.vel.y *= Math.pow(0.2, dt * 60);
    player.pos.z -= player.speedForward * 0.8 * dt;
    player.pos.y += dt * 32;
    player.roll *= Math.pow(0.2, dt * 60);
    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 0.8);
    camera.pos.y = player.pos.y + 14;
    camera.pos.z = player.pos.z + 68;
    animateStars(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  function updateGameOver(dt) {
    skyMix = Math.max(0, skyMix - dt * 0.3);
    player.vel.x *= Math.pow(0.12, dt * 60);
    player.vel.y *= Math.pow(0.12, dt * 60);
    player.pos.z -= player.speedForward * 0.25 * dt;
    player.roll *= Math.pow(0.2, dt * 60);
    camera.pos.x += (player.pos.x - camera.pos.x) * Math.min(1, dt * 0.9);
    camera.pos.y += (player.pos.y + 8 - camera.pos.y) * Math.min(1, dt * 0.9);
    camera.pos.z += (player.pos.z + 44 - camera.pos.z) * Math.min(1, dt * 1.1);
    animateStars(dt);
    updateProjectiles(dt);
    updateExplosions(dt);
  }

  // === 星パーティクルの更新 ===
  function animateStars(dt) {
    if (!spaceScene.stars.length) return;
    const parallax = player.speedForward * 0.85;
    for (const star of spaceScene.stars) {
      star.twinkle = (star.twinkle + dt * 2.6) % (Math.PI * 2);
      star.z -= parallax * dt;
      if (star.z > player.pos.z - 200) {
        star.z = player.pos.z - 2000 - Math.random() * 3200;
        star.x = (Math.random() * 2 - 1) * 260;
        star.y = Math.random() * 240 + 40;
      }
    }
  }

  // === 描画 ===
  function render() {
    ctx.fillStyle = "#020818";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (skyMix > 0.01) {
      ctx.fillStyle = `rgba(0, 12, 40, ${Math.min(1, skyMix * 0.9)})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    drawStars(skyMix);

    const hpText = `HP ${Math.max(0, Math.round(player.hp))}/${player.maxHp}`;
    const shieldText = `SHIELD ${Math.max(0, Math.round(player.shield))}`;
    const stockText = `STOCK ${player.stocks}/${player.maxStocks}`;
    const vitalsText = `${hpText} / ${shieldText} / ${stockText}`;
    const missileText = Number.isFinite(MISSILE_STOCK_MAX)
      ? `MISSILES ${missilesRemaining}/${MISSILE_STOCK_MAX}`
      : "MISSILES ∞"; // 無限ストックであることをHUDに表示
    if (gamePhase === "stage0") {
      hudLabel.textContent = "LAUNCH BAY / PREP SEQUENCE";
    } else if (stageClear) {
      hudLabel.textContent = "MISSION COMPLETE";
    } else if (gamePhase === "cityExit") {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText} / ASCENT`;
    } else if (gamePhase === "stage2" && boss.variant === "battleship" && boss.active && !boss.destroyed) {
      const waveStatus = boss.waveCharge > 0.05 ? "WAVECANNON" : `BATTLESHIP HP ${Math.max(0, boss.hp)}`;
      hudLabel.textContent = `ASTEROID RUN / ${vitalsText} / ${missileText} / ${waveStatus}`;
    } else if (gamePhase === "gameOver") {
      hudLabel.textContent = `SYSTEM FAILURE / ${vitalsText}`;
    } else if (environment === "space") {
      hudLabel.textContent = `ASTEROID RUN / ${vitalsText} / ${missileText}`;
    } else if (boss.active && !boss.destroyed) {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText} / BOSS HP ${Math.max(0, boss.hp)}`;
    } else {
      hudLabel.textContent = `CITY RUN / ${vitalsText} / ${missileText}`;
    }

    ctx.save();

    const cityFade = environment === "space" ? Math.max(0, 1 - skyMix * 1.4) : 1;
    if (cityFade > 0.02) {
      for (const obj of cityObjects) {
        if (obj.type === "ground") {
          drawEdges(obj.edges, `rgba(32, 126, 255, ${0.25 * cityFade})`, 1, `rgba(10, 66, 200, ${0.6 * cityFade})`);
        } else if (obj.type === "building") {
          drawEdges(obj.edges, `rgba(0, 123, 255, ${0.78 * cityFade})`, 1.6, `rgba(0, 123, 255, ${0.7 * cityFade})`);
        } else if (obj.type === "gate") {
          const pulse = 0.6 + Math.sin(performance.now() * 0.003) * 0.4;
          drawEdges(obj.edges, `rgba(0, 173, 255, ${Math.min(1, pulse) * cityFade})`, 2.2, `rgba(0, 140, 255, ${0.9 * cityFade})`);
        }
      }
    }

    if (skyMix > 0.08) {
      drawSpaceScenery(skyMix);
      drawGuideBeacons(skyMix);
    }

    if (gamePhase === "stage0") {
      drawStage0Hangar();
    }

    // ボス描画
    const bossGroups = getBossEdgeGroups();
    if (bossGroups) {
      if (bossGroups.variant === "battleship") {
        drawEdges(bossGroups.engines.edges, "rgba(0, 120, 255, 0.6)", 2.6, "rgba(0, 150, 255, 0.6)", bossGroups.engines.transform);
        drawEdges(bossGroups.fins.edges, "rgba(0, 160, 255, 0.65)", 2.4, "rgba(0, 190, 255, 0.65)", bossGroups.fins.transform);
        drawEdges(bossGroups.base.edges, "rgba(0, 190, 255, 0.78)", 2.8, "rgba(0, 220, 255, 0.85)", bossGroups.base.transform);
        drawEdges(bossGroups.bridge.edges, "rgba(0, 255, 255, 0.82)", 3.0, "rgba(0, 255, 230, 0.88)", bossGroups.bridge.transform);
        drawEdges(bossGroups.cannon.edges, "rgba(0, 255, 220, 0.95)", 3.6, "rgba(0, 255, 200, 0.92)", bossGroups.cannon.transform);
        drawEdges(bossGroups.antenna.edges, "rgba(160, 255, 255, 0.8)", 2.2, "rgba(120, 220, 255, 0.82)", bossGroups.antenna.transform);
      } else {
        drawEdges(bossGroups.treads.edges, "rgba(0, 70, 160, 0.85)", 2.4, "rgba(0, 70, 220, 0.8)", bossGroups.treads.transform);
        drawEdges(bossGroups.base.edges, "rgba(0, 120, 220, 0.9)", 2.8, "rgba(0, 120, 255, 0.9)", bossGroups.base.transform);
        drawEdges(bossGroups.hull.edges, "rgba(0, 150, 255, 0.95)", 2.6, "rgba(0, 160, 255, 0.9)", bossGroups.hull.transform);
        drawEdges(bossGroups.turret.edges, "rgba(0, 200, 255, 0.95)", 3.0, "rgba(0, 220, 255, 0.9)", bossGroups.turret.transform);
        drawEdges(bossGroups.cannon.edges, "rgba(0, 255, 230, 0.95)", 3.2, "rgba(0, 255, 200, 0.9)", bossGroups.cannon.transform);
        drawEdges(bossGroups.antenna.edges, "rgba(0, 255, 255, 0.9)", 2.2, "rgba(0, 255, 255, 0.8)", bossGroups.antenna.transform);
      }
    }

    // 敵機描画（空中・地上の両方）
    const enemyTransform = { tx: 0, ty: 0, tz: 0 }; // 使い回してGC負荷を減らす
    for (const enemy of enemyObjects) {
      const pose = getEnemyPose(enemy);
      if (!pose) continue;
      enemyTransform.tx = pose.x;
      enemyTransform.ty = pose.y;
      enemyTransform.tz = pose.z;
      const flash = enemy.hitFlash ? Math.min(1, enemy.hitFlash) : 0;
      if (enemy.type === "air") {
        drawEdges(enemy.shape, `rgba(0, 255, 210, ${0.75 + flash * 0.5})`, 2.6 + flash * 0.8, `rgba(0, 220, 210, ${0.7 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "incoming") {
        drawEdges(enemy.shape, `rgba(0, 255, 148, ${0.75 + flash * 0.5})`, 2.8 + flash * 0.9, `rgba(0, 230, 140, ${0.75 + flash * 0.25})`, enemyTransform);
      } else if (enemy.type === "pursuer") {
        drawEdges(enemy.shape, `rgba(0, 160, 255, ${0.78 + flash * 0.5})`, 2.8 + flash * 1.0, `rgba(0, 130, 255, ${0.75 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "walker") {
        drawEdges(enemy.shape, `rgba(0, 180, 255, ${0.74 + flash * 0.4})`, 2.2 + flash * 0.6, `rgba(0, 200, 255, ${0.7 + flash * 0.3})`, enemyTransform);
      } else if (enemy.type === "ambush" || enemy.type === "spaceAir") {
        drawEdges(enemy.shape, `rgba(0, 255, 210, ${0.7 + flash * 0.35})`, 2.6 + flash * 0.8, `rgba(0, 220, 255, ${0.68 + flash * 0.3})`, enemyTransform);
      } else {
        drawEdges(enemy.shape, `rgba(0, 90, 255, ${0.72 + flash * 0.45})`, 2.0 + flash * 0.7, `rgba(0, 80, 255, ${0.68 + flash * 0.22})`, enemyTransform);
      }
      if (enemy.dropShield) {
        // シールド補給キャリアは金色の光輪で強調表示
        drawEdges(enemy.shape, `rgba(255, 220, 0, ${0.3 + flash * 0.4})`, 3.2 + flash * 0.9, `rgba(255, 180, 0, ${0.4 + flash * 0.3})`, enemyTransform);
      }
    }

    drawShieldPickups();
    drawExplosions();

    // 投射物描画（レーザー/ミサイル）
    drawLaserProjectiles(playerShots, "rgba(0, 255, 255, 0.95)", 2.2, 0.02);
    drawMissiles(playerMissiles);
    drawLaserProjectiles(enemyShots, "rgba(255, 90, 120, 0.95)", 1.8, 0.018);

    drawPlayerStatusOverlay(hpText, shieldText, stockText);

    // 自機描画
    if (player.visible && gamePhase === "stage0") {
      drawStage0Thruster();
    }
    const nowFrame = performance.now();
    const invulnFlash = player.invuln > 0 && Math.floor(nowFrame * 0.02) % 2 === 0;
    if (player.visible && (!invulnFlash || gamePhase === "stage0")) {
      drawEdges(getPlayerEdges(), "rgba(0, 188, 255, 0.95)", 2.4, "rgba(0, 188, 255, 0.9)");
    }

    // ボスHPバーとステージステータス
    if (boss.active && !boss.destroyed) {
      const hpRatio = Math.max(0, boss.hp / boss.maxHp);
      const barWidth = canvas.width * 0.4;
      const barX = (canvas.width - barWidth) * 0.5;
      const barY = canvas.height * 0.12;
      ctx.fillStyle = "rgba(10, 30, 60, 0.6)";
      ctx.fillRect(barX, barY, barWidth, 12);
      const barColor = boss.variant === "battleship" ? "rgba(0, 240, 255, 0.9)" : "rgba(0, 180, 255, 0.9)";
      const frameColor = boss.variant === "battleship" ? "rgba(0, 255, 240, 0.9)" : "rgba(0, 220, 255, 0.9)";
      ctx.fillStyle = barColor;
      ctx.fillRect(barX, barY, barWidth * hpRatio, 12);
      ctx.strokeStyle = frameColor;
      ctx.strokeRect(barX, barY, barWidth, 12);
    }
    if (gamePhase === "gameOver") {
      const elapsed = (nowFrame - gameOverTime) * 0.001;
      const alpha = Math.min(1, 0.3 + elapsed * 0.4);
      ctx.fillStyle = `rgba(255, 80, 120, ${alpha})`;
      ctx.font = `${64}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("GAME OVER", canvas.width * 0.5, canvas.height * 0.38);
      ctx.font = `${22}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.fillText("Press R to reload", canvas.width * 0.5, canvas.height * 0.45);
    } else if (stageClear) {
      const elapsed = (nowFrame - stageClearTime) * 0.001;
      const alpha = Math.min(1, 0.6 + elapsed * 0.35);
      ctx.fillStyle = `rgba(0, 255, 220, ${alpha})`;
      ctx.font = `${64}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("MISSION COMPLETE", canvas.width * 0.5, canvas.height * 0.38);
      ctx.font = `${24}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.fillText("Press R to replay (reload)", canvas.width * 0.5, canvas.height * 0.45);
    } else if (stage1Clear && gamePhase === "cityExit") {
      const alpha = Math.min(1, cityExitState.progress * 1.4);
      ctx.fillStyle = `rgba(0, 255, 200, ${alpha * 0.8})`;
      ctx.font = `${48}px "Helvetica Neue", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.fillText("STAGE 1 CLEAR", canvas.width * 0.5, canvas.height * 0.32);
    }

    ctx.restore();
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
